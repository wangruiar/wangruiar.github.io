<h2 id="题目要求">题目要求</h2>

<p>用pthread完成稠密矩阵向量乘法的并行算法：y=Ax，线程按输出数据y划分任务，每个线程负责计算y的m/p个元素。</p>

<p>矩阵和向量从磁盘读入，结果输出到磁盘，矩阵和向量文件格式统一按三元组存放。测试数据自己生成如8,000,000*8的矩阵。
测试NUMA非一直访问的影响；测试伪共享。</p>

<h2 id="实验过程">实验过程</h2>

<p>先看一下老师提供机器的配置：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lnszyd@201-NF5280M3:~<span class="nv">$ </span>numactl <span class="nt">-H</span>
available: 2 nodes <span class="o">(</span>0-1<span class="o">)</span>
node 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 24 25 26 27 28 29 30 31 32 33 34 35
node 0 size: 128924 MB
node 0 free: 106089 MB
node 1 cpus: 12 13 14 15 16 17 18 19 20 21 22 23 36 37 38 39 40 41 42 43 44 45 46 47
node 1 size: 128994 MB
node 1 free: 120915 MB
node distances:
node   0   1
  0:  10  20
  1:  20  10
</code></pre></div></div>

<h3 id="mulc">mul.c</h3>

<p>两个node共有48个可用线程。为了体现出NUMA非一致访问的影响，这里考虑使用24个线程加速（恰等于每个Node的线程数）。</p>

<p>开始生成<code class="highlighter-rouge">8000000*8</code>的矩阵时，生成的文件大小已经高达6G，然而在老师的机器上实际上用于矩阵乘法的时间只有<code class="highlighter-rouge">0.027s</code>，体现不出差异。这里和老师确认之后，直接将矩阵生成在内存，去掉了文件（如果要使用文件，只需要去掉我代码中的注释部分即可）。</p>

<p>此外，将矩阵大小扩大到<code class="highlighter-rouge">240000000*8</code>（行数增加三十倍），终于能够在运行时体现一点点的区别（内存占用约7.5G，恰略小于每个Node的空闲内存，不会引起内存页被SWAP到硬盘上导致减速）。</p>

<p>此外，要注意的是，要使用线程安全的计时函数。这里使用了OpenMP中的<code class="highlighter-rouge">omp_get_wtime()</code>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;omp.h&gt;
</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">numThreads</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span> <span class="c1">// row, col, number of threads, y=ax
</span><span class="kt">void</span> <span class="o">*</span><span class="nf">threadMul</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">rank</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">numThreads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">numThreads</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rank</span> <span class="o">*</span> <span class="n">block</span><span class="p">,</span> <span class="n">ie</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">?</span> <span class="n">i</span> <span class="o">+</span> <span class="n">block</span> <span class="o">:</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ie</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
			<span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">numThreads</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="n">a</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
	<span class="n">x</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
	<span class="n">y</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">();</span>
	<span class="cm">/*
	FILE *arrinput = fopen(argv[4], "r"), *vecinput = fopen(argv[5], "r");
	for (int i, j; fscanf(arrinput, "%d%d", &amp;i, &amp;j) != EOF;)
		fscanf(arrinput, "%d", &amp;a[i * n + j]);
	for (int i, j; fscanf(vecinput, "%d%d", &amp;i, &amp;j) != EOF;)
		fscanf(vecinput, "%d", &amp;x[i]);
	fclose(arrinput), fclose(vecinput);
	*/</span>
	<span class="kt">double</span> <span class="n">start</span> <span class="o">=</span> <span class="n">omp_get_wtime</span><span class="p">();</span>
	<span class="n">pthread_t</span> <span class="o">*</span><span class="n">thread_handles</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">numThreads</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pthread_t</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numThreads</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread_handles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">threadMul</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">i</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numThreads</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">pthread_join</span><span class="p">(</span><span class="n">thread_handles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">thread_handles</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"elapsed time: %f s"</span><span class="p">,</span> <span class="n">omp_get_wtime</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
	<span class="cm">/*
	FILE *output = fopen(argv[6], "w");
	for (int i = 0; i &lt; m; i++)
		fprintf(output, "%d ", y[i]);
	fclose(output);
	*/</span>
	<span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">free</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">free</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="数据生成器">数据生成器</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">FILE</span> <span class="o">*</span><span class="n">output</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"w"</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
			<span class="n">fprintf</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s">"%d %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">rand</span><span class="p">());</span>
	<span class="n">fclose</span><span class="p">(</span><span class="n">output</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="运行">运行</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lnszyd@201-NF5280M3:~<span class="nv">$ </span>gcc <span class="nt">-lpthread</span> <span class="nt">-fopenmp</span> <span class="nt">-o</span> mul mul.c
lnszyd@201-NF5280M3:~<span class="nv">$ </span><span class="nb">time</span> ./mul 240000000 8 24
elapsed <span class="nb">time</span>: 0.825514 s
real    0m26.875s
user    0m40.572s
sys     0m4.357s
lnszyd@201-NF5280M3:~<span class="nv">$ </span><span class="nb">time </span>numactl <span class="nt">--interleave</span><span class="o">=</span>all ./mul 240000000 8 24
elapsed <span class="nb">time</span>: 0.793493 s
real    0m28.699s
user    0m38.905s
sys     0m6.258s
lnszyd@201-NF5280M3:~<span class="nv">$ </span><span class="nb">time </span>numactl <span class="nt">-N</span> 0 <span class="nt">-m</span> 0 ./mul 240000000 8 24
elapsed <span class="nb">time</span>: 0.796528 s
real    0m26.820s
user    0m40.939s
sys     0m4.029s
lnszyd@201-NF5280M3:~<span class="nv">$ </span><span class="nb">time </span>numactl <span class="nt">-N</span> 0 <span class="nt">-m</span> 1 ./mul 240000000 8 24
elapsed <span class="nb">time</span>: 0.842660 s
real    0m28.698s
user    0m41.000s
sys     0m6.913s
</code></pre></div></div>

<p>如上，当使用Node 0的CPU但是使用Node 1的内存时，运行时间最长；其次是按默认情况运行；<code class="highlighter-rouge">numactl -N 0 -m 0</code>和<code class="highlighter-rouge">numactl -N 0 -m 0</code>都取得了一定的提升，前者是将内存随机均匀分布在整个内存，而后者绑定Node 0的内存和CPU。</p>

<p>下面测定访存一致性和伪共享。以下是0号Node访问0号node对应内存的记录。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lnszyd@201-NF5280M3:~<span class="nv">$ </span><span class="nb">sudo </span>perf c2c record  numactl <span class="nt">-N</span> 0 <span class="nt">-m</span> 0 ./mul 240000000 8 24
elapsed <span class="nb">time</span>: 0.905527 s[ perf record: Woken up 44 <span class="nb">times </span>to write data <span class="o">]</span>
<span class="o">[</span> perf record: Captured and wrote 11.816 MB perf.data <span class="o">(</span>140452 samples<span class="o">)</span> <span class="o">]</span>
lnszyd@201-NF5280M3:~<span class="nv">$ </span><span class="nb">sudo </span>perf c2c report
</code></pre></div></div>

<p>以下是0号Node访问1号node对应内存的记录。可以看到，这里的平均延迟大了很多。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lnszyd@201-NF5280M3:~<span class="nv">$ </span><span class="nb">sudo </span>perf c2c record  numactl <span class="nt">-N</span> 0 <span class="nt">-m</span> 1 ./mul 240000000 8 24
elapsed <span class="nb">time</span>: 0.929291 s[ perf record: Woken up 44 <span class="nb">times </span>to write data <span class="o">]</span>
<span class="o">[</span> perf record: Captured and wrote 11.267 MB perf.data <span class="o">(</span>133906 samples<span class="o">)</span> <span class="o">]</span>
lnszyd@201-NF5280M3:~<span class="nv">$ </span><span class="nb">sudo </span>perf c2c report
</code></pre></div></div>
