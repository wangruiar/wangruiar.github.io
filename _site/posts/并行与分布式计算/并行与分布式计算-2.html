<h1 id="课后作业">课后作业</h1>
<blockquote>
  <p>Why is it difficult to construct a true shared-memory computer? What is the minimum number of switches for connecting p processors to a shared memory with b words (where each word can be accessed independently)?</p>
</blockquote>

<p>共享内存的使用大大降低了在大规模数据处理过程中内存的消耗，但是共享内存的使用中有很多的陷阱，使理解和管理数据的局部性变得困难，一不注意就很容易导致程序崩溃。数据在读写过程中会更透明，但是数据写入进程或数据读出进程中，需要附加的数据结构控制。</p>

<p>每个word都需要一个开关，一共需要$b$个开关。</p>
<blockquote>
  <p>Consider a memory system with a level 1 cache of 32 KB and DRAM of 512 MB with the processor operating at 1 GHz. The latency to L1 cache is one cycle and the latency to DRAM is 100 cycles. In each memory cycle, the processor fetches four words (cache line size is four words). What is the peak achievable performance of a dot product of two vectors? Note: Where necessary, assume an optimal cache placement policy.</p>
  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* dot product loop */</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dim</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="n">dot_prod</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</code></pre></div>  </div>
</blockquote>

<p>最佳的内存策略是cache的一半用于缓存a，另一半用于缓存b。在这样的情况下，i每增加4，会发生两次cache miss，访问2次DRAM和6次cache。因此，完成上述循环，需要$\frac{dim}{4}\times(2\times 100+6\times 1)\times\frac{1}{1GHz}=dim\times 5.15\times 10^{-8}s$</p>

<blockquote>
  <h2 id="homework-asst-1">Homework-asst-1</h2>
  <p>Consider the following code where each line within the function represents a single function.</p>
  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
	<span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Point</span><span class="p">;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">innerProduct</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">float</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">,</span> <span class="c1">//Uses a load instruction
</span>		  <span class="n">x2</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">,</span>
		  <span class="n">product1</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">*</span> <span class="n">x2</span><span class="p">,</span>
		  <span class="n">y1</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">,</span>
		  <span class="n">y2</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">,</span>
		  <span class="n">product2</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">*</span> <span class="n">y2</span><span class="p">,</span>
		  <span class="n">inner</span> <span class="o">=</span> <span class="n">product1</span> <span class="o">+</span> <span class="n">product2</span><span class="p">;</span>
	<span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">inner</span><span class="p">;</span> <span class="c1">//Uses a store instruction
</span><span class="p">}</span>
<span class="kt">void</span> <span class="nf">computeInnerProduct</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span> <span class="n">a</span><span class="p">[],</span> <span class="k">const</span> <span class="n">Point</span> <span class="n">b</span><span class="p">[],</span> <span class="kt">float</span> <span class="n">result</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">innerProduct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div>  </div>
  <p>In the following questions, you can assume the following:</p>
  <ul>
    <li>$N$ is very large($&gt;10^6$).</li>
    <li>The machines described have modern CPUs, providing out-of-order execution, speculative execution, branch prediction, etc.</li>
    <li>There are no cache misses.</li>
    <li>The overhead of updating the loopindex i is negligible.</li>
    <li>The overhead due to procedure calls, as well as starting and ending loops, is negligible.</li>
  </ul>

  <p>Problem 1: Instruction-Level Parallelism
Suppose you have a machine $M_1$ with two load/store unites that can each load or store a single value on each clock cycle, and one arithmetic unit can perform one arithmetic operation(e.g., multiplication or addition) on each clock cycle.
A. Assume that the load/store and arithmetic have latencies of one cycle. How many clock cycles would be required to execute <code class="highlighter-rouge">computeInnerProduct</code> as a function of <code class="highlighter-rouge">n</code>? Explain what limits the performance.</p>
</blockquote>

<p>做一次<code class="highlighter-rouge">innerProduct</code>需要7次load，1次store，3次arithmetic. 而<code class="highlighter-rouge">computeInnerProduct</code>的循环中有n次<code class="highlighter-rouge">innerProduct</code>，如果不考虑循环处的消耗的话需要$11n$个cycle。</p>
<blockquote>
  <p>老师上课说，这一问也考虑了不同指令的并行，所以还是3n。</p>
</blockquote>

<blockquote>
  <p>B. Now assume that the load/store and arithmetic unit have latencies of 10 clock cycles, but they are fully pipelined, able to initiate new operations every clock cycle. How many cycles would be required to execute <code class="highlighter-rouge">computeInnerProduction</code> as a function of <code class="highlighter-rouge">n</code>?Explain how this relates your answer to Part-A.</p>
</blockquote>

<p>最理想的情况下不发生竞争，完全并行，因此不考虑循环处的消耗的话需要<code class="highlighter-rouge">3n</code>个cycle。和A部分相比，由于指令完全流水线，因此每次循环时的load/store/arithmetic间没有间断。</p>
<blockquote>
  <p>Problem 2: SIMD with ISPC
Consider running the following ISPC code.</p>
  <pre><code class="language-autoit">export void computeInnerProductISPC(
	uniform point[] a,
	uniform point[] b,
	uniform float[] result,
	uniform int n
)
{
	foreach (i = 0...n)
		result[i] = a[i].x * b[i].x + a[i].y * b[i].y;
}
</code></pre>
  <p>Suppose machine $M_2$ has one 8-wide SIMD load/store unit, and one 8-wide SIMD arithmetic unit. both have latencies of one clock cycle.
A. How many clock cycles would be required to execute <code class="highlighter-rouge">computeInnerProductISPC</code> as a function of <code class="highlighter-rouge">n</code>? Explain what lmits the performance.</p>
</blockquote>

<p>对于循环中的每个i，发生可4次load，1次store，3次arithmetic。所以一共需要$8n$个cycle。</p>
<blockquote>
  <p>老师上课说是$\frac{5}{8}n$，因为5次内存操作是瓶颈，8路同时运算。</p>
</blockquote>

<blockquote>
  <p>B. If we run the <code class="highlighter-rouge">computeInnerProductISPC</code> on a five-core machine $M_3$, where each core has the same SIMD capabilities as $M_2$, what would be the best speedup it could achieve over the single-core performance of Part-A? Explain.</p>
</blockquote>

<p>最理想的情况下能够加速5倍，因为每个进程间的计算是彼此独立的。</p>
<blockquote>
  <p>由于使用了SIMD指令集，这是一套单盒的指令集，没有多核并行的内容，所以没有加速，一倍。太坑了！！！</p>
</blockquote>

<blockquote>
  <h2 id="homework-asst-2">Homework-asst-2</h2>

  <p>Parallel Fractal Generation Using Pthreads</p>

  <p>Leverage the sample code provided in the course web site.</p>

  <p>Build and run the code in the prob1_mandelbrot_threads directory of the Assignment 1 code base.This program produces the image file mandelbrot-vV -serial.ppm, where V is the view index. This image is a visualization of a famous set of complex numbers called the Mandelbrot set. As you can see in the images below, the result is a familiar and beautiful fractal. Each pixel in the image corresponds to a value in the complex plane, and the brightness of each pixel is proportional to the computational cost of determining whether the value is contained in the Mandelbrot set—white pixels required the maximum (256) number of iterations, dark ones only a few iterations, and colored pixels were somewhere in between. (See function mandel() defined in mandelbrot.cpp.) You can learn more about the definition of the Mandelbrot set at en.wikipedia.org/wiki/Mandelbrot set. Use the command option “–view V ” for V between 0 and 6 to get the different images. You can click the links below to see the different images on a browser. Take the time to do this—the images are quite striking. (View 0 is not shown— it is all white.)</p>

  <p>Your job is to parallelize the computation of the images using Pthreads. The command-line option “–threads T” specifies that the computation is to be partitioned over T threads. In function mandelbrotThread(), located in mandelbrot.cpp, the main application thread creates T-1 additional thread using pthread_create(). It waits for these threads to complete using pthread_join(). Currently, neither the launched threads nor the main thread do any computation, and so the program generates an error message. You should add code to the workerThreadStart() function to accomplish this task. You will not need to use of any other Pthread API calls in this assignment. What you need to do:</p>

  <ol>
    <li>Modify the code in mandelbrot.cpp to parallelize the Mandelbrot generation using two cores. Specifically, compute the top half of the image in thread 0, and the bottom half of the image in thread 1. This type of problem decomposition is referred to as spatial decomposition since different spatial regions of the image are computed by different processors.</li>
    <li>Extend your code to utilize T threads for {2, 4, 8,16} , partitioning the image generation work into the appropriate number of horizontal blocks. You will need to modify the code in function workerThreadStart, to partition the work over the threads.</li>
    <li>To confirm (or disprove) your hypothesis, measure the amount of time each thread requires to complete its work by inserting timing code at the beginning and end of workerThreadStart(). How do your measurements explain the speedup graph you previously created?</li>
  </ol>
</blockquote>

<p>问题本身还是比较容易的，只在<code class="highlighter-rouge">mandelbrot.cpp</code>中加入了$126\sim 134$行和$164\sim 174$行就解决了问题，详见源代码。以上三个文件都在文件夹<code class="highlighter-rouge">prog1_mandelbrot_threads\</code>下，虽然老师给的代码有点乱，但好在写了<code class="highlighter-rouge">Makefile</code>。于是在终端中执行下列指令编译并运行。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>prog1_mandelbrot_threads
make
./mandelbrot <span class="nt">-t</span> 2
</code></pre></div></div>
<p>得到如下输出。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[mandelbrot serial]:            [708.508] ms
Wrote image file mandelbrot-serial.ppmHello world from thread 0
Hello world from thread 1
Hello world from thread 0
Hello world from thread 1
Hello world from thread 0
Hello world from thread 1
Hello world from thread 0
Hello world from thread 1
Hello world from thread 0
Hello world from thread 1
[mandelbrot thread]:            [336.797] ms
Wrote image file mandelbrot-thread.ppm++++                            (2.10x speedup from 2 threads)
</code></pre></div></div>
<p>以上输出表明并行计算的版本在双线程时比单线程快了2.1倍。生成了两个ppm格式的文件<code class="highlighter-rouge">mandelbrot-serial.ppm</code>、<code class="highlighter-rouge">mandelbrot-thread.ppm</code>，但是并看不了。使用下述指令进行转码：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ffmpeg <span class="nt">-i</span> mandelbrot-serial.ppm mandelbrot-serial.png
ffmpeg <span class="nt">-i</span> mandelbrot-thread.ppm mandelbrot-thread.png
</code></pre></div></div>
<p>得到如下两张图片，可以看到也是一模一样的。</p>

<table>
  <thead>
    <tr>
      <th><img src="/public/image/2019-03-25-1.png" alt="" /></th>
      <th><img src="/public/image/2019-03-25-2.png" alt="" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">mandelbrot-serial.png</code></td>
      <td><code class="highlighter-rouge">mandelbrot-thread.png</code></td>
    </tr>
  </tbody>
</table>

<p>假如要使用更多的线程进行计算，只需要修改<code class="highlighter-rouge">./mandelbrot -t 2</code>中<code class="highlighter-rouge">-t</code>后的参数即可。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./mandelbrot <span class="nt">-t</span> 4
<span class="o">[</span>mandelbrot serial]:            <span class="o">[</span>713.990] ms
Wrote image file mandelbrot-serial.ppmHello world from thread 1
Hello world from thread 2
Hello world from thread 0
Hello world from thread 3
Hello world from thread 1
Hello world from thread 2
Hello world from thread 0
Hello world from thread 3
Hello world from thread 1
Hello world from thread 0
Hello world from thread 2
Hello world from thread 3
Hello world from thread 1
Hello world from thread 2
Hello world from thread 0
Hello world from thread 3
Hello world from thread 1
Hello world from thread 2
Hello world from thread 0
Hello world from thread 3
<span class="o">[</span>mandelbrot thread]:            <span class="o">[</span>291.995] ms
Wrote image file mandelbrot-thread.ppm++++                            <span class="o">(</span>2.45x speedup from 4 threads<span class="o">)</span>
</code></pre></div></div>
<p>4线程的时候只快了2.45倍。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./mandelbrot <span class="nt">-t</span> 8
<span class="o">[</span>mandelbrot serial]:            <span class="o">[</span>707.881] ms
Wrote image file mandelbrot-serial.ppmHello world from thread 1
Hello world from thread 2
Hello world from thread 3
Hello world from thread 4
Hello world from thread 5
Hello world from thread 6
Hello world from thread 0
Hello world from thread 7
Hello world from thread 1
Hello world from thread 0
Hello world from thread 3
Hello world from thread 4
Hello world from thread 2
Hello world from thread 5
Hello world from thread 6
Hello world from thread 7
Hello world from thread 1
Hello world from thread 0
Hello world from thread 3
Hello world from thread 4
Hello world from thread 5
Hello world from thread 6
Hello world from thread 2
Hello world from thread 7
Hello world from thread 1
Hello world from thread 2
Hello world from thread 3
Hello world from thread 4
Hello world from thread 5
Hello world from thread 0
Hello world from thread 6
Hello world from thread 7
Hello world from thread 1
Hello world from thread 2
Hello world from thread 3
Hello world from thread 4
Hello world from thread 5
Hello world from thread 6
Hello world from thread 0
Hello world from thread 7
<span class="o">[</span>mandelbrot thread]:            <span class="o">[</span>196.575] ms
Wrote image file mandelbrot-thread.ppm++++                            <span class="o">(</span>3.60x speedup from 8 threads<span class="o">)</span>
</code></pre></div></div>
<p>8线程的时候3.6倍。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./mandelbrot <span class="nt">-t</span> 16
<span class="o">[</span>mandelbrot serial]:            <span class="o">[</span>738.481] ms
Wrote image file mandelbrot-serial.ppmHello world from thread 1
Hello world from thread 4
Hello world from thread 13
Hello world from thread 5
Hello world from thread 6
Hello world from thread 2
Hello world from thread 7
Hello world from thread 8
Hello world from thread 9
Hello world from thread 10
Hello world from thread 11
Hello world from thread 0
Hello world from thread 12
Hello world from thread 14
Hello world from thread 15
Hello world from thread 3
Hello world from thread 1
Hello world from thread 6
Hello world from thread 3
Hello world from thread 4
Hello world from thread 5
Hello world from thread 7
Hello world from thread 8
Hello world from thread 9
Hello world from thread 2
Hello world from thread 10
Hello world from thread 11
Hello world from thread 12
Hello world from thread 13
Hello world from thread 0
Hello world from thread 14
Hello world from thread 15
Hello world from thread 1
Hello world from thread 2
Hello world from thread 0
Hello world from thread 4
Hello world from thread 5
Hello world from thread 6
Hello world from thread 7
Hello world from thread 8
Hello world from thread 9
Hello world from thread 10
Hello world from thread 11
Hello world from thread 12
Hello world from thread 13
Hello world from thread 14
Hello world from thread 15
Hello world from thread 3
Hello world from thread 1
Hello world from thread 2
Hello world from thread 9
Hello world from thread 15
Hello world from thread 5
Hello world from thread 6
Hello world from thread 7
Hello world from thread 8
Hello world from thread 3
Hello world from thread 10
Hello world from thread 11
Hello world from thread 12
Hello world from thread 13
Hello world from thread 0
Hello world from thread 14
Hello world from thread 4
Hello world from thread 1
Hello world from thread 2
Hello world from thread 9
Hello world from thread 3
Hello world from thread 5
Hello world from thread 6
Hello world from thread 7
Hello world from thread 8
Hello world from thread 0
Hello world from thread 4
Hello world from thread 10
Hello world from thread 11
Hello world from thread 12
Hello world from thread 13
Hello world from thread 14
Hello world from thread 15
<span class="o">[</span>mandelbrot thread]:            <span class="o">[</span>185.233] ms
Wrote image file mandelbrot-thread.ppm++++                            <span class="o">(</span>3.99x speedup from 16 threads<span class="o">)</span>
</code></pre></div></div>
<p>16线程的时候3.99倍。</p>

<p>可以看到，加速比随进程增加而增加，但是增加的量不是线性的。这是因为并行的时候会有额外的开销。</p>
<h2 id="源代码">源代码</h2>
<h3 id="mandelbrotcpp">mandelbrot.cpp</h3>
<p>主要的代码，</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
</span><span class="c1">// Use this code to time your threads
// 我加入的代码在126~134行和164~174行
</span><span class="cp">#include "CycleTimer.h"
</span>
<span class="cm">/*

  15418 Spring 2012 note: This code was modified from example code
  originally provided by Intel.  To comply with Intel's open source
  licensing agreement, their copyright is retained below.

  -----------------------------------------------------------------

  Copyright (c) 2010-2011, Intel Corporation
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

	* Redistributions of source code must retain the above copyright
	  notice, this list of conditions and the following disclaimer.

	* Redistributions in binary form must reproduce the above copyright
	  notice, this list of conditions and the following disclaimer in the
	  documentation and/or other materials provided with the distribution.

	* Neither the name of Intel Corporation nor the names of its
	  contributors may be used to endorse or promote products derived from
	  this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
   IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/</span>

<span class="c1">// Core computation of Mandelbrot set membershop
// Iterate complex number c to determine whether it diverges
</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mandel</span><span class="p">(</span><span class="kt">float</span> <span class="n">c_re</span><span class="p">,</span> <span class="kt">float</span> <span class="n">c_im</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">float</span> <span class="n">z_re</span> <span class="o">=</span> <span class="n">c_re</span><span class="p">,</span> <span class="n">z_im</span> <span class="o">=</span> <span class="n">c_im</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">z_re</span> <span class="o">*</span> <span class="n">z_re</span> <span class="o">+</span> <span class="n">z_im</span> <span class="o">*</span> <span class="n">z_im</span> <span class="o">&gt;</span> <span class="mf">4.</span><span class="n">f</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="kt">float</span> <span class="n">new_re</span> <span class="o">=</span> <span class="n">z_re</span> <span class="o">*</span> <span class="n">z_re</span> <span class="o">-</span> <span class="n">z_im</span> <span class="o">*</span> <span class="n">z_im</span><span class="p">;</span>
		<span class="kt">float</span> <span class="n">new_im</span> <span class="o">=</span> <span class="mf">2.</span><span class="n">f</span> <span class="o">*</span> <span class="n">z_re</span> <span class="o">*</span> <span class="n">z_im</span><span class="p">;</span>
		<span class="n">z_re</span> <span class="o">=</span> <span class="n">c_re</span> <span class="o">+</span> <span class="n">new_re</span><span class="p">;</span>
		<span class="n">z_im</span> <span class="o">=</span> <span class="n">c_im</span> <span class="o">+</span> <span class="n">new_im</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//
// MandelbrotSerial --
//
// Compute an image visualizing the mandelbrot set.  The resulting
// array contains the number of iterations required before the complex
// number corresponding to a pixel could be rejected from the set.
//
// * x0, y0, x1, y1 describe the complex coordinates mapping
//   into the image viewport.
// * width, height describe the size of the output image
// * startRow, endRow describe how much of the image to compute
</span><span class="kt">void</span> <span class="nf">mandelbrotSerial</span><span class="p">(</span>
	<span class="kt">float</span> <span class="n">x0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y1</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">startRow</span><span class="p">,</span> <span class="kt">int</span> <span class="n">endRow</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">maxIterations</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">output</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">float</span> <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="n">width</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">/</span> <span class="n">height</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">startRow</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">endRow</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">dx</span><span class="p">;</span>
			<span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">dy</span><span class="p">;</span>

			<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">output</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">mandel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">maxIterations</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Struct for passing arguments to thread routine
</span><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
	<span class="kt">float</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxIterations</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">output</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">threadId</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numThreads</span><span class="p">;</span>
<span class="p">}</span> <span class="n">WorkerArgs</span><span class="p">;</span>

<span class="c1">//
// workerThreadStart --
//
// Thread entrypoint.
</span><span class="kt">void</span> <span class="o">*</span><span class="nf">workerThreadStart</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">threadArgs</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">WorkerArgs</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">WorkerArgs</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">threadArgs</span><span class="p">);</span>

	<span class="c1">// TODO: Implement worker thread here.
</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Hello world from thread %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">threadId</span><span class="p">);</span>
	<span class="c1">//以下是我加的第一部分内容
</span>	<span class="n">mandelbrotSerial</span><span class="p">(</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">y0</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">x1</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">y1</span><span class="p">,</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">/</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">numThreads</span> <span class="o">*</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">threadId</span><span class="p">,</span>																<span class="c1">//startRow
</span>		<span class="n">args</span><span class="o">-&gt;</span><span class="n">threadId</span> <span class="o">==</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">numThreads</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">:</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">/</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">numThreads</span> <span class="o">*</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">threadId</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="c1">//endRow
</span>		<span class="n">args</span><span class="o">-&gt;</span><span class="n">maxIterations</span><span class="p">,</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">);</span>
	<span class="c1">//增加完毕，只需要调用串行部分的代码即可
</span>	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//
// MandelbrotThread --
//
// Multi-threaded implementation of mandelbrot set image generation.
// Multi-threading performed via pthreads.
</span><span class="kt">void</span> <span class="nf">mandelbrotThread</span><span class="p">(</span>
	<span class="kt">int</span> <span class="n">numThreads</span><span class="p">,</span>
	<span class="kt">float</span> <span class="n">x0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y1</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">maxIterations</span><span class="p">,</span> <span class="kt">int</span> <span class="n">output</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">MAX_THREADS</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">numThreads</span> <span class="o">&gt;</span> <span class="n">MAX_THREADS</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error: Max allowed threads is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">MAX_THREADS</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pthread_t</span> <span class="n">workers</span><span class="p">[</span><span class="n">MAX_THREADS</span><span class="p">];</span>
	<span class="n">WorkerArgs</span> <span class="n">args</span><span class="p">[</span><span class="n">MAX_THREADS</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numThreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// TODO: Set thread arguments here.
</span>		<span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">threadId</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="c1">//以下是我加的第二段内容
</span>		<span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span><span class="p">;</span>
		<span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">;</span>
		<span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y0</span> <span class="o">=</span> <span class="n">y0</span><span class="p">;</span>
		<span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y1</span> <span class="o">=</span> <span class="n">y1</span><span class="p">;</span>
		<span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
		<span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
		<span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">maxIterations</span> <span class="o">=</span> <span class="n">maxIterations</span><span class="p">;</span>
		<span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="p">;</span>
		<span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">numThreads</span> <span class="o">=</span> <span class="n">numThreads</span><span class="p">;</span>
		<span class="c1">//增加完毕，把所有信息传给worker线程即可
</span>	<span class="p">}</span>

	<span class="c1">// Fire up the worker threads.  Note that numThreads-1 pthreads
</span>	<span class="c1">// are created and the main app thread is used as a worker as
</span>	<span class="c1">// well.
</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numThreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">workerThreadStart</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">workerThreadStart</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="c1">// wait for worker threads to complete
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numThreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pthread_join</span><span class="p">(</span><span class="n">workers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="maincpp">main.cpp</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
#include &lt;getopt.h&gt;
</span>
<span class="cp">#include "CycleTimer.h"
</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mandelbrotSerial</span><span class="p">(</span>
    <span class="kt">float</span> <span class="n">x0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y1</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">startRow</span><span class="p">,</span> <span class="kt">int</span> <span class="n">endRow</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">maxIterations</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">output</span><span class="p">[]);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">mandelbrotThread</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">numThreads</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">x0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y1</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">maxIterations</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">output</span><span class="p">[]);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">writePPMImage</span><span class="p">(</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">maxIterations</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">scaleAndShift</span><span class="p">(</span><span class="kt">float</span> <span class="o">&amp;</span><span class="n">x0</span><span class="p">,</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">x1</span><span class="p">,</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">y0</span><span class="p">,</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">y1</span><span class="p">,</span>
                   <span class="kt">float</span> <span class="n">scale</span><span class="p">,</span>
                   <span class="kt">float</span> <span class="n">shiftX</span><span class="p">,</span> <span class="kt">float</span> <span class="n">shiftY</span><span class="p">)</span>
<span class="p">{</span>

    <span class="n">x0</span> <span class="o">*=</span> <span class="n">scale</span><span class="p">;</span>
    <span class="n">x1</span> <span class="o">*=</span> <span class="n">scale</span><span class="p">;</span>
    <span class="n">y0</span> <span class="o">*=</span> <span class="n">scale</span><span class="p">;</span>
    <span class="n">y1</span> <span class="o">*=</span> <span class="n">scale</span><span class="p">;</span>
    <span class="n">x0</span> <span class="o">+=</span> <span class="n">shiftX</span><span class="p">;</span>
    <span class="n">x1</span> <span class="o">+=</span> <span class="n">shiftX</span><span class="p">;</span>
    <span class="n">y0</span> <span class="o">+=</span> <span class="n">shiftY</span><span class="p">;</span>
    <span class="n">y1</span> <span class="o">+=</span> <span class="n">shiftY</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">usage</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">progname</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Usage: %s [options]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">progname</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Program Options:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  -t  --threads &lt;N&gt;  Use N threads</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  -v  --view &lt;INT&gt;   Use specified view settings (1-6)</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  -?  --help         This message</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">verifyResult</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">gold</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
<span class="p">{</span>

    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">gold</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">j</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Mismatch : [%d][%d], Expected : %d, Actual : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                       <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">gold</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">j</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">j</span><span class="p">]);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define VIEWCNT 6
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">1440</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">900</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">maxIterations</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">numThreads</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">x0</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.167</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">x1</span> <span class="o">=</span> <span class="mf">1.167</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">y0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">y1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// Support VIEWCNT views
</span>    <span class="kt">float</span> <span class="n">scaleValues</span><span class="p">[</span><span class="n">VIEWCNT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.015</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.02</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.02</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.02</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.002</span><span class="n">f</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">shiftXs</span><span class="p">[</span><span class="n">VIEWCNT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.98</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.35</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.4</span><span class="n">f</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">shiftYs</span><span class="p">[</span><span class="n">VIEWCNT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.30</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.05</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.73</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">};</span>

    <span class="c1">// parse commandline options ////////////////////////////////////////////
</span>    <span class="kt">int</span> <span class="n">opt</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">struct</span> <span class="n">option</span> <span class="n">long_options</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="s">"threads"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">'t'</span><span class="p">},</span>
        <span class="p">{</span><span class="s">"view"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">'v'</span><span class="p">},</span>
        <span class="p">{</span><span class="s">"help"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">'?'</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}};</span>

    <span class="k">while</span> <span class="p">((</span><span class="n">opt</span> <span class="o">=</span> <span class="n">getopt_long</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">"t:v:?"</span><span class="p">,</span> <span class="n">long_options</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">opt</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="k">case</span> <span class="sc">'t'</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="n">numThreads</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">optarg</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="sc">'v'</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">viewIndex</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">optarg</span><span class="p">);</span>
            <span class="c1">// change view settings
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">viewIndex</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">viewIndex</span> <span class="o">&lt;=</span> <span class="n">VIEWCNT</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">float</span> <span class="n">scaleValue</span> <span class="o">=</span> <span class="n">scaleValues</span><span class="p">[</span><span class="n">viewIndex</span><span class="p">];</span>
                <span class="kt">float</span> <span class="n">shiftX</span> <span class="o">=</span> <span class="n">shiftXs</span><span class="p">[</span><span class="n">viewIndex</span><span class="p">];</span>
                <span class="kt">float</span> <span class="n">shiftY</span> <span class="o">=</span> <span class="n">shiftYs</span><span class="p">[</span><span class="n">viewIndex</span><span class="p">];</span>
                <span class="n">scaleAndShift</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">scaleValue</span><span class="p">,</span> <span class="n">shiftX</span><span class="p">,</span> <span class="n">shiftY</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Invalid view index</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="sc">'?'</span><span class="p">:</span>
        <span class="nl">default:</span>
            <span class="n">usage</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// end parsing of commandline options
</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">output_serial</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">];</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">output_thread</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">];</span>

    <span class="c1">//
</span>    <span class="c1">// Run the serial implementation.  Run the code three times and
</span>    <span class="c1">// take the minimum to get a good estimate.
</span>    <span class="c1">//
</span>    <span class="n">memset</span><span class="p">(</span><span class="n">output_serial</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="kt">double</span> <span class="n">minSerial</span> <span class="o">=</span> <span class="mf">1e30</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">double</span> <span class="n">startTime</span> <span class="o">=</span> <span class="n">CycleTimer</span><span class="o">::</span><span class="n">currentSeconds</span><span class="p">();</span>
        <span class="n">mandelbrotSerial</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">maxIterations</span><span class="p">,</span> <span class="n">output_serial</span><span class="p">);</span>
        <span class="kt">double</span> <span class="n">endTime</span> <span class="o">=</span> <span class="n">CycleTimer</span><span class="o">::</span><span class="n">currentSeconds</span><span class="p">();</span>
        <span class="n">minSerial</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">minSerial</span><span class="p">,</span> <span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[mandelbrot serial]:</span><span class="se">\t\t</span><span class="s">[%.3f] ms</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">minSerial</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
    <span class="n">writePPMImage</span><span class="p">(</span><span class="n">output_serial</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="s">"mandelbrot-serial.ppm"</span><span class="p">,</span> <span class="n">maxIterations</span><span class="p">);</span>

    <span class="c1">//
</span>    <span class="c1">// Run the threaded version
</span>    <span class="c1">//
</span>    <span class="n">memset</span><span class="p">(</span><span class="n">output_thread</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="kt">double</span> <span class="n">minThread</span> <span class="o">=</span> <span class="mf">1e30</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">double</span> <span class="n">startTime</span> <span class="o">=</span> <span class="n">CycleTimer</span><span class="o">::</span><span class="n">currentSeconds</span><span class="p">();</span>
        <span class="n">mandelbrotThread</span><span class="p">(</span><span class="n">numThreads</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">maxIterations</span><span class="p">,</span> <span class="n">output_thread</span><span class="p">);</span>
        <span class="kt">double</span> <span class="n">endTime</span> <span class="o">=</span> <span class="n">CycleTimer</span><span class="o">::</span><span class="n">currentSeconds</span><span class="p">();</span>
        <span class="n">minThread</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">minThread</span><span class="p">,</span> <span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[mandelbrot thread]:</span><span class="se">\t\t</span><span class="s">[%.3f] ms</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">minThread</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
    <span class="n">writePPMImage</span><span class="p">(</span><span class="n">output_thread</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="s">"mandelbrot-thread.ppm"</span><span class="p">,</span> <span class="n">maxIterations</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">verifyResult</span><span class="p">(</span><span class="n">output_serial</span><span class="p">,</span> <span class="n">output_thread</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"ERROR : Output from threads does not match serial output</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

        <span class="k">delete</span><span class="p">[]</span> <span class="n">output_serial</span><span class="p">;</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">output_thread</span><span class="p">;</span>

        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// compute speedup
</span>    <span class="n">printf</span><span class="p">(</span><span class="s">"++++</span><span class="se">\t\t\t\t</span><span class="s">(%.2fx speedup from %d threads)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">minSerial</span> <span class="o">/</span> <span class="n">minThread</span><span class="p">,</span> <span class="n">numThreads</span><span class="p">);</span>

    <span class="k">delete</span><span class="p">[]</span> <span class="n">output_serial</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">output_thread</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="makefile">Makefile</h3>
<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CXX</span><span class="o">=</span>g++ <span class="nt">-m64</span>
<span class="nv">CXXFLAGS</span><span class="o">=</span><span class="nt">-I</span>../common <span class="nt">-Iobjs</span>/ <span class="nt">-O3</span> <span class="nt">-Wall</span>

<span class="nv">APP_NAME</span><span class="o">=</span>mandelbrot
<span class="nv">OBJDIR</span><span class="o">=</span>objs
<span class="nv">COMMONDIR</span><span class="o">=</span>../common

<span class="nv">PPM_CXX</span><span class="o">=</span><span class="nv">$(COMMONDIR)</span>/ppm.cpp
<span class="nv">PPM_OBJ</span><span class="o">=</span><span class="err">$</span><span class="o">(</span>addprefix <span class="nv">$(OBJDIR)</span>/, <span class="err">$</span><span class="o">(</span>subst <span class="nv">$(COMMONDIR)</span>/,, <span class="err">$</span><span class="o">(</span>PPM_CXX:.cpp<span class="o">=</span>.o<span class="o">)))</span>


<span class="nl">default</span><span class="o">:</span> <span class="nf">$(APP_NAME)</span>

<span class="nl">.PHONY</span><span class="o">:</span> <span class="nf">dirs clean</span>

<span class="nl">dirs</span><span class="o">:</span>
		/bin/mkdir <span class="nt">-p</span> <span class="nv">$(OBJDIR)</span>/

<span class="nl">clean</span><span class="o">:</span>
		/bin/rm <span class="nt">-rf</span> <span class="nv">$(OBJDIR)</span> <span class="k">*</span>.ppm <span class="k">*</span>~ <span class="nv">$(APP_NAME)</span>

<span class="nv">OBJS</span><span class="o">=</span><span class="nv">$(OBJDIR)</span>/main.o <span class="nv">$(OBJDIR)</span>/mandelbrot.o <span class="nv">$(PPM_OBJ)</span>

<span class="nl">$(APP_NAME)</span><span class="o">:</span> <span class="nf">dirs $(OBJS)</span>
		<span class="nv">$(CXX)</span> <span class="nv">$(CXXFLAGS)</span> <span class="nt">-o</span> <span class="nv">$@</span> <span class="nv">$(OBJS)</span> <span class="nt">-lm</span> <span class="nt">-lpthread</span>

<span class="nl">$(OBJDIR)/%.o</span><span class="o">:</span> <span class="nf">%.cpp</span>
		<span class="nv">$(CXX)</span> <span class="nv">$&lt;</span> <span class="nv">$(CXXFLAGS)</span> <span class="nt">-c</span> <span class="nt">-o</span> <span class="nv">$@</span>

<span class="nl">$(OBJDIR)/%.o</span><span class="o">:</span> <span class="nf">$(COMMONDIR)/%.cpp</span>
	<span class="nv">$(CXX)</span> <span class="nv">$&lt;</span> <span class="nv">$(CXXFLAGS)</span> <span class="nt">-c</span> <span class="nt">-o</span> <span class="nv">$@</span>

<span class="nl">$(OBJDIR)/main.o</span><span class="o">:</span> <span class="nf">$(COMMONDIR)/CycleTimer.h</span>
</code></pre></div></div>
