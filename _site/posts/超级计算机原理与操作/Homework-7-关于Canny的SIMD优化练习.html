<p><a href="https://easyhpc.org/problems/program/374/">题目链接</a></p>

<h2 id="题目简述">题目简述</h2>

<p>针对经典的边缘检测Canny算子，使用串行代码按四个步骤实现其基本功能，再应用SIMD优化串行实现（可使用Intel IPP库），并且分析优化的思路和流程，最终给出实验结果（使用图表总结），考虑优化前后边缘检测算法性能和运行效率有哪些变化。</p>

<h2 id="详细说明">详细说明</h2>

<h3 id="canny算法">Canny算法</h3>

<p>Canny是最早由John F. Canny在1986年提出的边缘检测算法，并沿用至今。</p>
<blockquote>
  <p>Canny, John. “A computational approach to edge detection.” Readings in Computer Vision. 1987. 184-203.</p>
</blockquote>

<p>John F. Canny给出了评价边缘检测性能优劣的三个指标：</p>

<ol>
  <li>Good detection。即要使得标记真正边缘点的失误率和标记非边缘点的错误率尽量低。</li>
  <li>Good localization。即检测出的边缘点要尽可能在实际边缘的中心；</li>
  <li>Only one response to a single edge。当同一条边有多个响应时，仅能取其一作为标记。即数学上单个边缘产生多个响应的概率越低越好，并且尽量抑制图像噪声产生虚假边缘。</li>
</ol>

<p>Canny算法是以上述三个指标为优化目标的求解问题的最优解，即在对图像中物体边缘敏感性的同时，也抑制或消除噪声的影响。其主要步骤如下：</p>

<ol>
  <li>Noise Reduction（可使用高斯滤波器去噪）</li>
  <li>Finding Intensity Gradient of the Image（可在横纵轴分别用Sobal算子初步计算出两张梯度图，再最终计算出原图梯度的幅值和方向，其中方向最终近似到四个角度0, 45, 90, 135）</li>
  <li>Non-maximum Suppression（边缘细化，使其更清晰）</li>
  <li>Hysteresis Thresholding（最终使用双阈值来选择边缘像素，生成边缘检测结果）</li>
</ol>

<h3 id="simd">SIMD</h3>

<p>SIMD全称Single Instruction Multiple Data，单指令多数据流，它已经成为Intel处理器的重要性能扩展。目前Intel处理器支持的SIMD技术包括MMX,SS,,AVX,AVX256,AVX512等。</p>

<p>MMX提供了8个64bit的寄存器进行SIMD操作，SSE系列提供了128bit的8个寄存器进行SIMD指令操作，而AVX指令则支持256/512bit的SIMD操作。</p>

<p>目前SIMD指令可以有多种方法进行使用，如下图所示，包括使用编译器的自动向量化（Auto-vectorization）支持、使用编译器指示符（compiler directive）、使用编译器的内建函数（intrinsic）和直接使用汇编语言编写汇编函数再从C++代码中调用汇编函数。</p>

<h3 id="参考资料">参考资料</h3>

<ul>
  <li><a href="http://agner.org/optimize/">http://agner.org/optimize/</a></li>
  <li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/-tutorials/imgproc/table_of_content_imgproc/table_of_content_imgproc.html">http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/-tutorials/imgproc/table_of_content_imgproc/table_of_content_imgproc.html</a></li>
  <li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html">http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html</a></li>
  <li><a href="http://marathon.csee.usf.edu/edge/edge_detection.html">http://marathon.csee.usf.edu/edge/edge_detection.html</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Canny_edge_detector">https://en.wikipedia.org/wiki/Canny_edge_detector</a></li>
  <li><a href="http://matlabserver.cs.rug.nl/">http://matlabserver.cs.rug.nl/</a></li>
</ul>

<h2 id="实验环境">实验环境</h2>

<h3 id="软件">软件</h3>

<ul>
  <li>Windows 10, 64-bit  (Build 17763) 10.0.17763</li>
  <li>Windows Subsystem for Linux [Ubuntu 18.04.2 LTS]：WSL是以软件的形式运行在Windows下的Linux子系统，是近些年微软推出来的新工具，可以在Windows系统上原生运行Linux。</li>
  <li>gcc version 7.3.0 (Ubuntu 7.3.0-27ubuntu1~18.04)：C语言程序编译器，Ubuntu自带的编译器。</li>
</ul>

<p>大部分开发环境安装在WSL上，较之于双系统、虚拟机等其他开发方案，更加方便，也方便直接使用Linux下的一些指令。</p>

<h3 id="硬件">硬件</h3>

<p>所用机器型号为VAIO Z Flip 2016。</p>

<ul>
  <li><a href="https://ark.intel.com/content/www/cn/zh/ark/products/91167/intel-core-i7-6567u-processor-4m-cache-up-to-3-60-ghz.html">Intel(R) Core(TM) i7-6567U CPU @3.30GHZ 3.31GHz</a>：2核心4线程，TDP 28W，支持的指令集扩展包括SSE4.1、SSE4.2、AVX2。</li>
  <li>8.00GB RAM</li>
</ul>

<h2 id="实验过程">实验过程</h2>

<h3 id="编译代码">编译代码</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-o</span> canny_edge canny_edge.c hysteresis.c pgm_io.c <span class="nt">-lm</span> <span class="nt">-fopenmp</span> <span class="nt">-fopt-info</span> <span class="nt">-O3</span>
canny_edge.c:439:3: note: loop vectorized
canny_edge.c:422:3: note: loop vectorized
canny_edge.c:422:3: note: loop versioned <span class="k">for </span>vectorization because of possible aliasing
canny_edge.c:439:3: note: loop turned into
non-loop<span class="p">;</span> it never loops.
canny_edge.c:439:3: note: loop with 7 iterations completely unrolled
canny_edge.c:422:3: note: loop turned into
non-loop<span class="p">;</span> it never loops.
canny_edge.c:422:3: note: loop with 14 iterations completely unrolled
canny_edge.c:392:6: note: loop turned into
non-loop<span class="p">;</span> it never loops.
canny_edge.c:392:6: note: loop with 7 iterations completely unrolled
canny_edge.c:560:2: note: loop vectorized
canny_edge.c:560:2: note: loop turned into
non-loop<span class="p">;</span> it never loops.
canny_edge.c:560:2: note: loop with 6 iterations completely unrolled
canny_edge.c:536:6: note: loop turned into
non-loop<span class="p">;</span> it never loops.
canny_edge.c:536:6: note: loop with 3 iterations completely unrolled
hysteresis.c:28:2: note: loop turned into non-loop<span class="p">;</span> it never loops.
hysteresis.c:28:2: note: loop with 9 iterations completely unrolled
hysteresis.c:31:48: note: basic block vectorized
hysteresis.c:28:54: note: basic block vectorized
hysteresis.c:28:2: note: loop turned into non-loop<span class="p">;</span> it never loops.
hysteresis.c:28:2: note: loop with 9 iterations completely unrolled
hysteresis.c:98:9: note: Loop 2 distributed: split to 1 loops and 1 library calls.
hysteresis.c:89:11: note: Loop 8 distributed: split to 0 loops and 1 library calls.
hysteresis.c:98:9: note: loop vectorized
hysteresis.c:78:7: note: loop vectorized
hysteresis.c:71:7: note: loop vectorized
hysteresis.c:63:10: note: loop vectorized
hysteresis.c:48:6: note: loop turned into non-loop<span class="p">;</span> it never loops
hysteresis.c:48:6: note: loop turned into non-loop<span class="p">;</span> it never loops.
hysteresis.c:48:6: note: loop with 2 iterations completely unrolled
hysteresis.c:48:6: note: loop turned into non-loop<span class="p">;</span> it never loops
hysteresis.c:48:6: note: loop turned into non-loop<span class="p">;</span> it never loops.
hysteresis.c:48:6: note: loop with 15 iterations completely unrolled
hysteresis.c:48:6: note: loop turned into non-loop<span class="p">;</span> it never loops.
hysteresis.c:48:6: note: loop with 15 iterations completely unrolled
hysteresis.c:48:6: note: loop turned into non-loop<span class="p">;</span> it never loops.
hysteresis.c:48:6: note: loop with 15 iterations completely unrolled
hysteresis.c:28:54: note: basic block vectorized
hysteresis.c:28:54: note: basic block vectorized
hysteresis.c:175:49: note: loop vectorized
hysteresis.c:172:46: note: loop vectorized
hysteresis.c:165:6: note: loop turned into
non-loop<span class="p">;</span> it never loops.
hysteresis.c:165:6: note: loop with 15 iterations completely unrolled
hysteresis.c:165:6: note: loop turned into
non-loop<span class="p">;</span> it never loops.
hysteresis.c:165:6: note: loop with 15 iterations completely unrolled
</code></pre></div></div>

<p>稍微解释一下某些编译参数。</p>

<ul>
  <li><code class="highlighter-rouge">-lm</code>，为正常使用<code class="highlighter-rouge">sqrt</code>函数，需要链接到数学库。</li>
  <li><code class="highlighter-rouge">-fopenmp</code>，打开<code class="highlighter-rouge">openmp</code>的支持，因为在这里我是使用编译制导<code class="highlighter-rouge">#pragma omp simd</code>来将原来的算法<code class="highlighter-rouge">simd</code>化的。</li>
  <li><code class="highlighter-rouge">-fopt-info</code>，显示被优化的部分。可以看到上面的输出中，很多循环和代码块被向量化了。</li>
  <li><code class="highlighter-rouge">-O3</code>，启用空间换速度的代码优化。之所以要开启<code class="highlighter-rouge">O3</code>选项，是因为simd向量化通常是需要内存对齐的，因此会需要额外的空间。作为对比，关闭<code class="highlighter-rouge">-O3</code>的时候没有被向量化（没有输出），而只开到<code class="highlighter-rouge">-O2</code>的时候只有六个循环被向量化（<code class="highlighter-rouge">-O3</code>会将某些内部循环展开，使得更多的可被向量化的语句被发现）。此外，还有一个优化级别最高的<code class="highlighter-rouge">-Ofast</code>，经过测试，向量化语句的数量和<code class="highlighter-rouge">-O3</code>一样是14个，而这一级别的优化却可能会使得算法的输出不符合预期，因此没有选用。</li>
</ul>

<h3 id="将输入图片转码成pgm格式">将输入图片转码成pgm格式</h3>

<p>由于实现的算法只支持pgm格式，需要先将输入文件转码：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ffmpeg <span class="nt">-i</span> MizunoAi.jpg MizunoAi.pgm
</code></pre></div></div>

<p>由于老师给的图片尺寸不够大，在我的机器上很难明显显示出并行化优化后加速的效果，这里我使用<a href="https://wu-kan.github.io/posts/并行与分布式计算/并行与分布式计算-1">waifu2x算法</a>生成了一张<code class="highlighter-rouge">12000*6748</code>的图片作为测试。当然使用老师提供的图片也是可以正常运行的，只是优化的效果就不太明显了。</p>

<h3 id="测试运行时间">测试运行时间</h3>

<p>使用<code class="highlighter-rouge">time</code>指令来测试运行时间，以下测试时间均为多次测试后得到的稳定时间。</p>

<p>根据原作者写的README和我自己的调参，发现当运行参数设置为<code class="highlighter-rouge">2.4 0.5 0.9</code>时有不错的运行效果。</p>

<h4 id="-o3优化">-O3优化</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">time</span> ./canny_edge MizunoAi.pgm 2.4 0.5 0.9

real    0m8.387s
user    0m7.125s
sys     0m1.203s
</code></pre></div></div>

<h4 id="-o2优化">-O2优化</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">time</span> ./canny_edge MizunoAi.pgm 2.4 0.5 0.9
real    0m9.052s
user    0m7.719s
sys     0m1.281s
</code></pre></div></div>

<h4 id="-o1优化">-O1优化</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">time</span> ./canny_edge MizunoAi.pgm 2.4 0.5 0.9
real    0m9.640s
user    0m8.266s
sys     0m1.234s
</code></pre></div></div>

<h4 id="无优化">无优化</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">time</span> ./canny_edge MizunoAi.pgm 2.4 0.5 0.9
real    0m20.856s
user    0m19.469s
sys     0m1.250s
</code></pre></div></div>

<h3 id="运行结果">运行结果</h3>

<p>将图片转化回png格式方便查看：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ffmpeg <span class="nt">-i</span> MizunoAi.pgm_s_2.40_l_0.50_h_0.90.pgm MizunoAi.png
</code></pre></div></div>

<p>下面对比算法的效果。</p>

<table>
  <thead>
    <tr>
      <th><code class="highlighter-rouge">MizunoAi.jpg</code></th>
      <th><img src="/public/image/2019-06-03-1.jpg" alt="`MizunoAi.jpg`" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">MizunoAi.png</code></td>
      <td><img src="/public/image/2019-06-03-2.png" alt="`MizunoAi.png`" /></td>
    </tr>
  </tbody>
</table>

<p>可以看到，从无优化到<code class="highlighter-rouge">-O1</code>优化这一段的提速是最多的。原因所在，我猜想是<code class="highlighter-rouge">-O1</code>优化的大部分其实是一些其他的优化，例如循环分支预测等。随着优化等级的提升，某些内嵌的循环被展开，就会有更多的语句块被编译器判断为可向量化，运行时间会有不断的减少。</p>

<h2 id="源代码">源代码</h2>

<h3 id="canny_edgec"><code class="highlighter-rouge">canny_edge.c</code></h3>

<p>上层代码，接受运行参数。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*

## 个人信息
吴坎
中山大学数据科学与计算机学院
17级计算机科学技术（超级计算方向）
17341163
wukan3@mail2.sysu.edu.cn
## 简单说明
使用OpenMP的SIMD指令将原作者（见下）实现的Canny边缘检测的算法并行化。在原先的算法上去除了一些循环依赖，并加上了编译制导。
### 编译指令
`gcc -o canny_edge canny_edge.c hysteresis.c pgm_io.c -lm -fopenmp -fopt-info -O3`
### 使用说明
运行下述指令，可以运行并行化的边缘检测算法。参数的用法和原先串行版本相同，可以在下面或者代码中找到解释。

`./canny_edge &lt;image&gt; &lt;sigma&gt; &lt;tlow&gt; &lt;thigh&gt; [writedirim]`

可以阅读[我的这篇博客](https://wu-kan.github.io/posts/超级计算机原理与操作/Homework-7-关于Canny的SIMD优化练习)

*/</span>

<span class="cm">/*******************************************************************************
* --------------------------------------------
*(c) 2001 University of South Florida, Tampa
* Use, or copying without permission prohibited.
* PERMISSION TO USE
* In transmitting this software, permission to use for research and
* educational purposes is hereby granted.  This software may be copied for
* archival and backup purposes only.  This software may not be transmitted
* to a third party without prior permission of the copyright holder. This
* permission may be granted only by Mike Heath or Prof. Sudeep Sarkar of
* University of South Florida (sarkar@csee.usf.edu). Acknowledgment as
* appropriate is respectfully requested.
*
*  Heath, M., Sarkar, S., Sanocki, T., and Bowyer, K. Comparison of edge
*    detectors: a methodology and initial study, Computer Vision and Image
*    Understanding 69 (1), 38-54, January 1998.
*  Heath, M., Sarkar, S., Sanocki, T. and Bowyer, K.W. A Robust Visual
*    Method for Assessing the Relative Performance of Edge Detection
*    Algorithms, IEEE Transactions on Pattern Analysis and Machine
*    Intelligence 19 (12),  1338-1359, December 1997.
*  ------------------------------------------------------
*
* PROGRAM: canny_edge
* PURPOSE: This program implements a "Canny" edge detector. The processing
* steps are as follows:
*
*   1) Convolve the image with a separable gaussian filter.
*   2) Take the dx and dy the first derivatives using [-1,0,1] and [1,0,-1]'.
*   3) Compute the magnitude: sqrt(dx*dx+dy*dy).
*   4) Perform non-maximal suppression.
*   5) Perform hysteresis.
*
* The user must input three parameters. These are as follows:
*
*   sigma = The standard deviation of the gaussian smoothing filter.
*   tlow  = Specifies the low value to use in hysteresis. This is a
*           fraction (0-1) of the computed high threshold edge strength value.
*   thigh = Specifies the high value to use in hysteresis. This fraction (0-1)
*           specifies the percentage point in a histogram of the gradient of
*           the magnitude. Magnitude values of zero are not counted in the
*           histogram.
*
* NAME: Mike Heath
*       Computer Vision Laboratory
*       University of South Floeida
*       heath@csee.usf.edu
*
* DATE: 2/15/96
*
* Modified: 5/17/96 - To write out a floating point RAW headerless file of
*                     the edge gradient "up the edge" where the angle is
*                     defined in radians counterclockwise from the x direction.
*                     (Mike Heath)
*******************************************************************************/</span>
<span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
</span>
<span class="cp">#define VERBOSE 0
#define BOOSTBLURFACTOR 90.0
</span>
<span class="kt">int</span> <span class="n">read_pgm_image</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">infilename</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">image</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cols</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">write_pgm_image</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">outfilename</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">comment</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxval</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">canny</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">float</span> <span class="n">sigma</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tlow</span><span class="p">,</span> <span class="kt">float</span> <span class="n">thigh</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">edge</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">non_max_supp</span><span class="p">(</span><span class="kt">short</span> <span class="o">*</span><span class="n">mag</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">gradx</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">grady</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nrows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncols</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">gaussian_smooth</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">float</span> <span class="n">sigma</span><span class="p">,</span> <span class="kt">short</span> <span class="kt">int</span> <span class="o">**</span><span class="n">smoothedim</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">make_gaussian_kernel</span><span class="p">(</span><span class="kt">float</span> <span class="n">sigma</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">kernel</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">windowsize</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">derrivative_x_y</span><span class="p">(</span><span class="kt">short</span> <span class="kt">int</span> <span class="o">*</span><span class="n">smoothedim</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">short</span> <span class="kt">int</span> <span class="o">**</span><span class="n">delta_x</span><span class="p">,</span> <span class="kt">short</span> <span class="kt">int</span> <span class="o">**</span><span class="n">delta_y</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">magnitude_x_y</span><span class="p">(</span><span class="kt">short</span> <span class="kt">int</span> <span class="o">*</span><span class="n">delta_x</span><span class="p">,</span> <span class="kt">short</span> <span class="kt">int</span> <span class="o">*</span><span class="n">delta_y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">short</span> <span class="kt">int</span> <span class="o">**</span><span class="n">magnitude</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">apply_hysteresis</span><span class="p">(</span><span class="kt">short</span> <span class="kt">int</span> <span class="o">*</span><span class="n">mag</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">nms</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tlow</span><span class="p">,</span> <span class="kt">float</span> <span class="n">thigh</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">edge</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">radian_direction</span><span class="p">(</span><span class="kt">short</span> <span class="kt">int</span> <span class="o">*</span><span class="n">delta_x</span><span class="p">,</span> <span class="kt">short</span> <span class="kt">int</span> <span class="o">*</span><span class="n">delta_y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">dir_radians</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xdirtag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ydirtag</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">angle_radians</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">infilename</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="cm">/* Name of the input image */</span>
		<span class="o">*</span><span class="n">dirfilename</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="cm">/* Name of the output gradient direction image */</span>
		<span class="n">outfilename</span><span class="p">[</span><span class="mi">128</span><span class="p">],</span>	<span class="cm">/* Name of the output "edge" image */</span>
		<span class="n">composedfname</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>  <span class="cm">/* Name of the output "direction" image */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span>	<span class="cm">/* The input image */</span>
		<span class="o">*</span><span class="n">edge</span><span class="p">;</span>				 <span class="cm">/* The output edge image */</span>
	<span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">;</span>			 <span class="cm">/* The dimensions of the image. */</span>
	<span class="kt">float</span> <span class="n">sigma</span><span class="p">,</span>			 <span class="cm">/* Standard deviation of the gaussian kernel. */</span>
		<span class="n">tlow</span><span class="p">,</span>				 <span class="cm">/* Fraction of the high threshold in hysteresis. */</span>
		<span class="n">thigh</span><span class="p">;</span>				 <span class="cm">/* High hysteresis threshold control. The actual
					  threshold is the (100 * thigh) percentage point
					  in the histogram of the magnitude of the
					  gradient image that passes non-maximal
					  suppression. */</span>

	<span class="cm">/****************************************************************************
* Get the command line arguments.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span>
				<span class="s">"&lt;USAGE&gt; %s image sigma tlow thigh [writedirim]</span><span class="se">\n\n</span><span class="s">"</span>
				<span class="s">"      image:      An image to process. Must be in PGM format.</span><span class="se">\n</span><span class="s">"</span>
				<span class="s">"      sigma:      Standard deviation of the gaussian blur kernel.</span><span class="se">\n</span><span class="s">"</span>
				<span class="s">"      tlow:       Fraction (0.0-1.0) of the high edge strength threshold.</span><span class="se">\n</span><span class="s">"</span>
				<span class="s">"      thigh:      Fraction (0.0-1.0) of the distribution of non-zero edge strengths for hysteresis. The fraction is used to compute the high edge strength threshold.</span><span class="se">\n</span><span class="s">"</span>
				<span class="s">"      writedirim: Optional argument to output  a floating point  direction image.</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span>
				<span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">infilename</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">sigma</span> <span class="o">=</span> <span class="n">atof</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">tlow</span> <span class="o">=</span> <span class="n">atof</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="n">thigh</span> <span class="o">=</span> <span class="n">atof</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">)</span>
		<span class="n">dirfilename</span> <span class="o">=</span> <span class="n">infilename</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dirfilename</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/****************************************************************************
* Read in the image. This read function allocates memory for the image.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VERBOSE</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Reading the image %s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">infilename</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_pgm_image</span><span class="p">(</span><span class="n">infilename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">image</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rows</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error reading the input image, %s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">infilename</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/****************************************************************************
* Perform the edge detection. All of the work takes place here.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VERBOSE</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Starting Canny edge detection.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dirfilename</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">composedfname</span><span class="p">,</span> <span class="s">"%s_s_%3.2f_l_%3.2f_h_%3.2f.fim"</span><span class="p">,</span> <span class="n">infilename</span><span class="p">,</span>
				<span class="n">sigma</span><span class="p">,</span> <span class="n">tlow</span><span class="p">,</span> <span class="n">thigh</span><span class="p">);</span>
		<span class="n">dirfilename</span> <span class="o">=</span> <span class="n">composedfname</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">canny</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">tlow</span><span class="p">,</span> <span class="n">thigh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edge</span><span class="p">,</span> <span class="n">dirfilename</span><span class="p">);</span>
	<span class="cm">/****************************************************************************
* Write out the edge image to a file.
****************************************************************************/</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">outfilename</span><span class="p">,</span> <span class="s">"%s_s_%3.2f_l_%3.2f_h_%3.2f.pgm"</span><span class="p">,</span> <span class="n">infilename</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">tlow</span><span class="p">,</span> <span class="n">thigh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VERBOSE</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Writing the edge iname in the file %s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">outfilename</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write_pgm_image</span><span class="p">(</span><span class="n">outfilename</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error writing the edge image, %s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">outfilename</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************
* PROCEDURE: canny
* PURPOSE: To perform canny edge detection.
* NAME: Mike Heath
* DATE: 2/15/96
*******************************************************************************/</span>
<span class="kt">void</span> <span class="nf">canny</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">float</span> <span class="n">sigma</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tlow</span><span class="p">,</span> <span class="kt">float</span> <span class="n">thigh</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">edge</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">FILE</span> <span class="o">*</span><span class="n">fpdir</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* File to write the gradient image to.     */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">nms</span><span class="p">;</span>	<span class="cm">/* Points that are local maximal magnitude. */</span>
	<span class="kt">short</span> <span class="kt">int</span> <span class="o">*</span><span class="n">smoothedim</span><span class="p">,</span> <span class="cm">/* The image after gaussian smoothing.      */</span>
		<span class="o">*</span><span class="n">delta_x</span><span class="p">,</span>		   <span class="cm">/* The first devivative image, x-direction. */</span>
		<span class="o">*</span><span class="n">delta_y</span><span class="p">,</span>		   <span class="cm">/* The first derivative image, y-direction. */</span>
		<span class="o">*</span><span class="n">magnitude</span><span class="p">;</span>		   <span class="cm">/* The magnitude of the gadient image.      */</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">pos</span><span class="p">;</span>
	<span class="kt">float</span> <span class="o">*</span><span class="n">dir_radians</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* Gradient direction image.                */</span>

	<span class="cm">/****************************************************************************
* Perform gaussian smoothing on the image using the input standard
* deviation.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VERBOSE</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Smoothing the image using a gaussian kernel.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">gaussian_smooth</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smoothedim</span><span class="p">);</span>

	<span class="cm">/****************************************************************************
* Compute the first derivative in the x and y directions.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VERBOSE</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Computing the X and Y first derivatives.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">derrivative_x_y</span><span class="p">(</span><span class="n">smoothedim</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delta_x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delta_y</span><span class="p">);</span>

	<span class="cm">/****************************************************************************
* This option to write out the direction of the edge gradient was added
* to make the information available for computing an edge quality figure
* of merit.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fname</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/*************************************************************************
* Compute the direction up the gradient, in radians that are
* specified counteclockwise from the positive x-axis.
*************************************************************************/</span>
		<span class="n">radian_direction</span><span class="p">(</span><span class="n">delta_x</span><span class="p">,</span> <span class="n">delta_y</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dir_radians</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/*************************************************************************
* Write the gradient direction image out to a file.
*************************************************************************/</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">fpdir</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">"wb"</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error opening the file %s for writing.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fname</span><span class="p">);</span>
			<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">fwrite</span><span class="p">(</span><span class="n">dir_radians</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">,</span> <span class="n">fpdir</span><span class="p">);</span>
		<span class="n">fclose</span><span class="p">(</span><span class="n">fpdir</span><span class="p">);</span>
		<span class="n">free</span><span class="p">(</span><span class="n">dir_radians</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/****************************************************************************
* Compute the magnitude of the gradient.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VERBOSE</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Computing the magnitude of the gradient.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">magnitude_x_y</span><span class="p">(</span><span class="n">delta_x</span><span class="p">,</span> <span class="n">delta_y</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">magnitude</span><span class="p">);</span>

	<span class="cm">/****************************************************************************
* Perform non-maximal suppression.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VERBOSE</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Doing the non-maximal suppression.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">nms</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error allocating the nms image.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">non_max_supp</span><span class="p">(</span><span class="n">magnitude</span><span class="p">,</span> <span class="n">delta_x</span><span class="p">,</span> <span class="n">delta_y</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">nms</span><span class="p">);</span>

	<span class="cm">/****************************************************************************
* Use hysteresis to mark the edge pixels.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VERBOSE</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Doing hysteresis thresholding.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">edge</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error allocating the edge image.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">apply_hysteresis</span><span class="p">(</span><span class="n">magnitude</span><span class="p">,</span> <span class="n">nms</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">tlow</span><span class="p">,</span> <span class="n">thigh</span><span class="p">,</span> <span class="o">*</span><span class="n">edge</span><span class="p">);</span>

	<span class="cm">/****************************************************************************
* Free all of the memory that we allocated except for the edge image that
* is still being used to store out result.
****************************************************************************/</span>
	<span class="n">free</span><span class="p">(</span><span class="n">smoothedim</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">delta_x</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">delta_y</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">magnitude</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">nms</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************
* Procedure: radian_direction
* Purpose: To compute a direction of the gradient image from component dx and
* dy images. Because not all derriviatives are computed in the same way, this
* code allows for dx or dy to have been calculated in different ways.
*
* FOR X:  xdirtag = -1  for  [-1 0  1]
*         xdirtag =  1  for  [ 1 0 -1]
*
* FOR Y:  ydirtag = -1  for  [-1 0  1]'
*         ydirtag =  1  for  [ 1 0 -1]'
*
* The resulting angle is in radians measured counterclockwise from the
* xdirection. The angle points "up the gradient".
*******************************************************************************/</span>
<span class="kt">void</span> <span class="nf">radian_direction</span><span class="p">(</span><span class="kt">short</span> <span class="kt">int</span> <span class="o">*</span><span class="n">delta_x</span><span class="p">,</span> <span class="kt">short</span> <span class="kt">int</span> <span class="o">*</span><span class="n">delta_y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">dir_radians</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xdirtag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ydirtag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">float</span> <span class="o">*</span><span class="n">dirim</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/****************************************************************************
* Allocate an image to store the direction of the gradient.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dirim</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error allocating the gradient direction image.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">dir_radians</span> <span class="o">=</span> <span class="n">dirim</span><span class="p">;</span>

<span class="cp">#pragma omp simd
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">pos</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">double</span> <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">delta_x</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
		<span class="kt">double</span> <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">delta_y</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">xdirtag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">dx</span> <span class="o">=</span> <span class="o">-</span><span class="n">dx</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ydirtag</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">dy</span> <span class="o">=</span> <span class="o">-</span><span class="n">dy</span><span class="p">;</span>

		<span class="n">dirim</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">angle_radians</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************
* FUNCTION: angle_radians
* PURPOSE: This procedure computes the angle of a vector with components x and
* y. It returns this angle in radians with the answer being in the range
* 0 &lt;= angle &lt;2*PI.
*******************************************************************************/</span>
<span class="kt">double</span> <span class="nf">angle_radians</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">double</span> <span class="n">xu</span><span class="p">,</span> <span class="n">yu</span><span class="p">,</span> <span class="n">ang</span><span class="p">;</span>

	<span class="n">xu</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="n">yu</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">xu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">yu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">ang</span> <span class="o">=</span> <span class="n">atan</span><span class="p">(</span><span class="n">yu</span> <span class="o">/</span> <span class="n">xu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">ang</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">acos</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">ang</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">acos</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">ang</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">acos</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">ang</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************
* PROCEDURE: magnitude_x_y
* PURPOSE: Compute the magnitude of the gradient. This is the square root of
* the sum of the squared derivative values.
* NAME: Mike Heath
* DATE: 2/15/96
*******************************************************************************/</span>
<span class="kt">void</span> <span class="nf">magnitude_x_y</span><span class="p">(</span><span class="kt">short</span> <span class="kt">int</span> <span class="o">*</span><span class="n">delta_x</span><span class="p">,</span> <span class="kt">short</span> <span class="kt">int</span> <span class="o">*</span><span class="n">delta_y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span>
				   <span class="kt">short</span> <span class="kt">int</span> <span class="o">**</span><span class="n">magnitude</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/****************************************************************************
* Allocate an image to store the magnitude of the gradient.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">magnitude</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error allocating the magnitude image.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#pragma omp simd
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">pos</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">sq1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">delta_x</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">delta_x</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">sq2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">delta_y</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">delta_y</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
		<span class="p">(</span><span class="o">*</span><span class="n">magnitude</span><span class="p">)[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)(</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">sq1</span> <span class="o">+</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">sq2</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************
* PROCEDURE: derrivative_x_y
* PURPOSE: Compute the first derivative of the image in both the x any y
* directions. The differential filters that are used are:
*
*                                          -1
*         dx =  -1 0 +1     and       dy =  0
*                                          +1
*
* NAME: Mike Heath
* DATE: 2/15/96
*******************************************************************************/</span>
<span class="kt">void</span> <span class="nf">derrivative_x_y</span><span class="p">(</span><span class="kt">short</span> <span class="kt">int</span> <span class="o">*</span><span class="n">smoothedim</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span>
					 <span class="kt">short</span> <span class="kt">int</span> <span class="o">**</span><span class="n">delta_x</span><span class="p">,</span> <span class="kt">short</span> <span class="kt">int</span> <span class="o">**</span><span class="n">delta_y</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/****************************************************************************
* Allocate images to store the derivatives.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">(((</span><span class="o">*</span><span class="n">delta_x</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error allocating the delta_x image.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(((</span><span class="o">*</span><span class="n">delta_y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error allocating the delta_x image.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/****************************************************************************
* Compute the x-derivative. Adjust the derivative at the borders to avoid
* losing pixels.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VERBOSE</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"   Computing the X-direction derivative.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="cp">#pragma omp simd
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">cols</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">delta_x</span><span class="p">)[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothedim</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">smoothedim</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
		<span class="n">pos</span><span class="o">++</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">c</span><span class="o">++</span><span class="p">,</span> <span class="n">pos</span><span class="o">++</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">delta_x</span><span class="p">)[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothedim</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">smoothedim</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="p">(</span><span class="o">*</span><span class="n">delta_x</span><span class="p">)[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothedim</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">-</span> <span class="n">smoothedim</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/****************************************************************************
* Compute the y-derivative. Adjust the derivative at the borders to avoid
* losing pixels.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VERBOSE</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"   Computing the Y-direction derivative.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="cp">#pragma omp simd
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">delta_y</span><span class="p">)[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothedim</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="n">cols</span><span class="p">]</span> <span class="o">-</span> <span class="n">smoothedim</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">cols</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">r</span><span class="o">++</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+=</span> <span class="n">cols</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="p">(</span><span class="o">*</span><span class="n">delta_y</span><span class="p">)[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothedim</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="n">cols</span><span class="p">]</span> <span class="o">-</span> <span class="n">smoothedim</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="n">cols</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="p">(</span><span class="o">*</span><span class="n">delta_y</span><span class="p">)[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothedim</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">-</span> <span class="n">smoothedim</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="n">cols</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************
* PROCEDURE: gaussian_smooth
* PURPOSE: Blur an image with a gaussian filter.
* NAME: Mike Heath
* DATE: 2/15/96
*******************************************************************************/</span>
<span class="kt">void</span> <span class="nf">gaussian_smooth</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">float</span> <span class="n">sigma</span><span class="p">,</span>
					 <span class="kt">short</span> <span class="kt">int</span> <span class="o">**</span><span class="n">smoothedim</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">windowsize</span><span class="p">,</span> <span class="cm">/* Dimension of the gaussian kernel. */</span>
		<span class="n">center</span><span class="p">;</span>		<span class="cm">/* Half of the windowsize. */</span>
	<span class="kt">float</span> <span class="o">*</span><span class="n">tempim</span><span class="p">,</span>  <span class="cm">/* Buffer for separable filter gaussian smoothing. */</span>
		<span class="o">*</span><span class="n">kernel</span><span class="p">;</span>	<span class="cm">/* A one dimensional gaussian kernel. */</span>

	<span class="cm">/****************************************************************************
* Create a 1-dimensional gaussian smoothing kernel.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VERBOSE</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"   Computing the gaussian smoothing kernel.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">make_gaussian_kernel</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">windowsize</span><span class="p">);</span>
	<span class="n">center</span> <span class="o">=</span> <span class="n">windowsize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/****************************************************************************
* Allocate a temporary buffer image and the smoothed image.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tempim</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error allocating the buffer image.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(((</span><span class="o">*</span><span class="n">smoothedim</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">,</span>
											 <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span> <span class="kt">int</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error allocating the smoothed image.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/****************************************************************************
* Blur in the x - direction.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VERBOSE</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"   Bluring the image in the X-direction.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="cp">#pragma omp simd
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">float</span> <span class="n">dot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">cc</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">center</span><span class="p">);</span> <span class="n">cc</span> <span class="o">&lt;=</span> <span class="n">center</span><span class="p">;</span> <span class="n">cc</span><span class="o">++</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(((</span><span class="n">c</span> <span class="o">+</span> <span class="n">cc</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">c</span> <span class="o">+</span> <span class="n">cc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">))</span>
				<span class="p">{</span>
					<span class="n">dot</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">image</span><span class="p">[</span><span class="n">r</span> <span class="o">*</span> <span class="n">cols</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">cc</span><span class="p">)]</span> <span class="o">*</span> <span class="n">kernel</span><span class="p">[</span><span class="n">center</span> <span class="o">+</span> <span class="n">cc</span><span class="p">];</span>
					<span class="n">sum</span> <span class="o">+=</span> <span class="n">kernel</span><span class="p">[</span><span class="n">center</span> <span class="o">+</span> <span class="n">cc</span><span class="p">];</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">tempim</span><span class="p">[</span><span class="n">r</span> <span class="o">*</span> <span class="n">cols</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dot</span> <span class="o">/</span> <span class="n">sum</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/****************************************************************************
* Blur in the y - direction.
****************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VERBOSE</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"   Bluring the image in the Y-direction.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="cp">#pragma omp simd
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">float</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">dot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">rr</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">center</span><span class="p">);</span> <span class="n">rr</span> <span class="o">&lt;=</span> <span class="n">center</span><span class="p">;</span> <span class="n">rr</span><span class="o">++</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(((</span><span class="n">r</span> <span class="o">+</span> <span class="n">rr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">r</span> <span class="o">+</span> <span class="n">rr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">))</span>
				<span class="p">{</span>
					<span class="n">dot</span> <span class="o">+=</span> <span class="n">tempim</span><span class="p">[(</span><span class="n">r</span> <span class="o">+</span> <span class="n">rr</span><span class="p">)</span> <span class="o">*</span> <span class="n">cols</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="n">kernel</span><span class="p">[</span><span class="n">center</span> <span class="o">+</span> <span class="n">rr</span><span class="p">];</span>
					<span class="n">sum</span> <span class="o">+=</span> <span class="n">kernel</span><span class="p">[</span><span class="n">center</span> <span class="o">+</span> <span class="n">rr</span><span class="p">];</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="p">(</span><span class="o">*</span><span class="n">smoothedim</span><span class="p">)[</span><span class="n">r</span> <span class="o">*</span> <span class="n">cols</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span> <span class="kt">int</span><span class="p">)(</span><span class="n">dot</span> <span class="o">*</span> <span class="n">BOOSTBLURFACTOR</span> <span class="o">/</span> <span class="n">sum</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tempim</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">kernel</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************
* PROCEDURE: make_gaussian_kernel
* PURPOSE: Create a one dimensional gaussian kernel.
* NAME: Mike Heath
* DATE: 2/15/96
*******************************************************************************/</span>
<span class="kt">void</span> <span class="nf">make_gaussian_kernel</span><span class="p">(</span><span class="kt">float</span> <span class="n">sigma</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">kernel</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">windowsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">center</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">windowsize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">);</span>
	<span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">windowsize</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VERBOSE</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"      The kernel has %d elements.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">windowsize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">kernel</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">((</span><span class="o">*</span><span class="n">windowsize</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error callocing the gaussian kernel array.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">windowsize</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)(</span><span class="n">i</span> <span class="o">-</span> <span class="n">center</span><span class="p">);</span>
		<span class="n">fx</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">.</span><span class="mi">71828</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">/</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">6</span><span class="p">.</span><span class="mi">2831853</span><span class="p">));</span>
		<span class="p">(</span><span class="o">*</span><span class="n">kernel</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fx</span><span class="p">;</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">fx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">windowsize</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">(</span><span class="o">*</span><span class="n">kernel</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">sum</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VERBOSE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"The filter coefficients are:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">windowsize</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"kernel[%d] = %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">kernel</span><span class="p">)[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="hysteresisc">hysteresis.c</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//并行化(6/10/19)：在原先的算法上去除了一些循环依赖，并加上了OpenMP编译制导。
</span>
<span class="cm">/*******************************************************************************
* FILE: hysteresis.c
* This code was re-written by Mike Heath from original code obtained indirectly
* from Michigan State University. heath@csee.usf.edu (Re-written in 1996).
*******************************************************************************/</span>

<span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="cp">#define VERBOSE 0
</span>
<span class="cp">#define NOEDGE 255
#define POSSIBLE_EDGE 128
#define EDGE 0
</span>
<span class="cm">/*******************************************************************************
* PROCEDURE: follow_edges
* PURPOSE: This procedure edges is a recursive routine that traces edgs along
* all paths whose magnitude values remain above some specifyable lower
* threshhold.
* NAME: Mike Heath
* DATE: 2/15/96
*******************************************************************************/</span>
<span class="kt">void</span> <span class="nf">follow_edges</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">edgemapptr</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">edgemagptr</span><span class="p">,</span> <span class="kt">short</span> <span class="n">lowval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="n">y</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tempmapptr</span> <span class="o">=</span> <span class="n">edgemapptr</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">cols</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">short</span> <span class="o">*</span><span class="n">tempmagptr</span> <span class="o">=</span> <span class="n">edgemagptr</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">cols</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">tempmapptr</span> <span class="o">==</span> <span class="n">POSSIBLE_EDGE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">tempmagptr</span> <span class="o">&gt;</span> <span class="n">lowval</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="o">*</span><span class="n">tempmapptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">EDGE</span><span class="p">;</span>
			<span class="n">follow_edges</span><span class="p">(</span><span class="n">tempmapptr</span><span class="p">,</span> <span class="n">tempmagptr</span><span class="p">,</span> <span class="n">lowval</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************
* PROCEDURE: apply_hysteresis
* PURPOSE: This routine finds edges that are above some high threshhold or
* are connected to a high pixel by a path of pixels greater than a low
* threshold.
* NAME: Mike Heath
* DATE: 2/15/96
*******************************************************************************/</span>
<span class="kt">void</span> <span class="nf">apply_hysteresis</span><span class="p">(</span><span class="kt">short</span> <span class="kt">int</span> <span class="o">*</span><span class="n">mag</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">nms</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tlow</span><span class="p">,</span> <span class="kt">float</span> <span class="n">thigh</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">edge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">numedges</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lowcount</span><span class="p">,</span> <span class="n">highcount</span><span class="p">,</span> <span class="n">lowthreshold</span><span class="p">,</span> <span class="n">highthreshold</span><span class="p">,</span> <span class="n">hist</span><span class="p">[</span><span class="mi">32768</span><span class="p">];</span>
	<span class="kt">short</span> <span class="kt">int</span> <span class="n">maximum_mag</span><span class="p">,</span> <span class="n">sumpix</span><span class="p">;</span>

<span class="cm">/****************************************************************************
* Initialize the edge map to possible edges everywhere the non-maximal
* suppression suggested there could be an edge except for the border. At
* the border we say there can not be an edge because it makes the
* follow_edges algorithm more efficient to not worry about tracking an
* edge off the side of the image.
****************************************************************************/</span>
<span class="cp">#pragma omp simd
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">pos</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nms</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">POSSIBLE_EDGE</span><span class="p">)</span>
			<span class="n">edge</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">POSSIBLE_EDGE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">edge</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOEDGE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#pragma omp simd
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">cols</span><span class="p">;</span>
		<span class="n">edge</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOEDGE</span><span class="p">;</span>
		<span class="n">edge</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOEDGE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#pragma omp simd
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">cols</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">edge</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOEDGE</span><span class="p">;</span>
		<span class="n">edge</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOEDGE</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cm">/****************************************************************************
* Compute the histogram of the magnitude image. Then use the histogram to
* compute hysteresis thresholds.
****************************************************************************/</span>
<span class="cp">#pragma omp simd
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">32768</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hist</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">POSSIBLE_EDGE</span><span class="p">)</span>
			<span class="o">++</span><span class="n">hist</span><span class="p">[</span><span class="n">mag</span><span class="p">[</span><span class="n">pos</span><span class="p">]];</span> <span class="c1">//这里不可以向量化，可能会访问到同一块地址
</span>
<span class="cm">/****************************************************************************
* Compute the number of pixels that passed the nonmaximal suppression.
****************************************************************************/</span>
<span class="cp">#pragma omp simd reduction(+                         \
						   : numedges) reduction(max \
												 : maximum_mag)
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">32768</span><span class="p">;</span> <span class="o">++</span><span class="n">r</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
		<span class="p">{</span>
			<span class="n">maximum_mag</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
			<span class="n">numedges</span> <span class="o">+=</span> <span class="n">hist</span><span class="p">[</span><span class="n">r</span><span class="p">];</span>
		<span class="p">}</span>

	<span class="n">highcount</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">numedges</span> <span class="o">*</span> <span class="n">thigh</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">);</span>

	<span class="cm">/****************************************************************************
* Compute the high threshold value as the (100 * thigh) percentage point
* in the magnitude of the gradient histogram of all the pixels that passes
* non-maximal suppression. Then calculate the low threshold as a fraction
* of the computed high threshold value. John Canny said in his paper
* "A Computational Approach to Edge Detection" that "The ratio of the
* high to low threshold in the implementation is in the range two or three
* to one." That means that in terms of this implementation, we should
* choose tlow ~= 0.5 or 0.33333.
****************************************************************************/</span>
	<span class="n">highthreshold</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">numedges</span> <span class="o">=</span> <span class="n">hist</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">highthreshold</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">maximum_mag</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">numedges</span> <span class="o">&lt;</span> <span class="n">highcount</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">highthreshold</span><span class="o">++</span><span class="p">;</span>
		<span class="n">numedges</span> <span class="o">+=</span> <span class="n">hist</span><span class="p">[</span><span class="n">highthreshold</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">lowthreshold</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">highthreshold</span> <span class="o">*</span> <span class="n">tlow</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">VERBOSE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"The input low and high fractions of %f and %f computed to</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
			   <span class="n">tlow</span><span class="p">,</span> <span class="n">thigh</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"magnitude of the gradient threshold values of: %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
			   <span class="n">lowthreshold</span><span class="p">,</span> <span class="n">highthreshold</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cm">/****************************************************************************
* This loop looks for pixels above the highthreshold to locate edges and
* then calls follow_edges to continue the edge.
****************************************************************************/</span>
<span class="cp">#pragma omp simd
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">edge</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">POSSIBLE_EDGE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mag</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">highthreshold</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">edge</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">EDGE</span><span class="p">;</span>
			<span class="n">follow_edges</span><span class="p">((</span><span class="n">edge</span> <span class="o">+</span> <span class="n">pos</span><span class="p">),</span> <span class="p">(</span><span class="n">mag</span> <span class="o">+</span> <span class="n">pos</span><span class="p">),</span> <span class="n">lowthreshold</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
		<span class="p">}</span>

<span class="cm">/****************************************************************************
* Set all the remaining possible edges to non-edges.
****************************************************************************/</span>
<span class="cp">#pragma omp simd
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">!=</span> <span class="n">EDGE</span><span class="p">)</span>
			<span class="n">edge</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOEDGE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************
* PROCEDURE: non_max_supp
* PURPOSE: This routine applies non-maximal suppression to the magnitude of
* the gradient image.
* NAME: Mike Heath
* DATE: 2/15/96
*******************************************************************************/</span>
<span class="kt">void</span> <span class="nf">non_max_supp</span><span class="p">(</span><span class="kt">short</span> <span class="o">*</span><span class="n">mag</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">gradx</span><span class="p">,</span> <span class="kt">short</span> <span class="o">*</span><span class="n">grady</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nrows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncols</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/****************************************************************************
* Zero the edges of the result image.
****************************************************************************/</span>
<span class="cp">#pragma omp simd
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">ncols</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span>
		<span class="n">result</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">ncols</span> <span class="o">*</span> <span class="p">(</span><span class="n">nrows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#pragma omp simd
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">nrows</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span>
		<span class="n">result</span><span class="p">[</span><span class="n">ncols</span> <span class="o">*</span> <span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">ncols</span> <span class="o">*</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/****************************************************************************
* Suppress non-maximum points.
****************************************************************************/</span>
<span class="cp">#pragma omp simd
</span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">rowcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">rowcount</span> <span class="o">&lt;</span> <span class="n">nrows</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">rowcount</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">short</span> <span class="o">*</span><span class="n">magrowptr</span> <span class="o">=</span> <span class="n">mag</span> <span class="o">+</span> <span class="n">ncols</span> <span class="o">*</span> <span class="n">rowcount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			  <span class="o">*</span><span class="n">gxrowptr</span> <span class="o">=</span> <span class="n">gradx</span> <span class="o">+</span> <span class="n">ncols</span> <span class="o">*</span> <span class="n">rowcount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			  <span class="o">*</span><span class="n">gyrowptr</span> <span class="o">=</span> <span class="n">grady</span> <span class="o">+</span> <span class="n">ncols</span> <span class="o">*</span> <span class="n">rowcount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			  <span class="o">*</span><span class="n">magptr</span> <span class="o">=</span> <span class="n">magrowptr</span><span class="p">,</span>
			  <span class="o">*</span><span class="n">gxptr</span> <span class="o">=</span> <span class="n">gxrowptr</span><span class="p">,</span>
			  <span class="o">*</span><span class="n">gyptr</span> <span class="o">=</span> <span class="n">gyrowptr</span><span class="p">;</span>

		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">resultrowptr</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">ncols</span> <span class="o">*</span> <span class="n">rowcount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					  <span class="o">*</span><span class="n">resultptr</span> <span class="o">=</span> <span class="n">resultrowptr</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">colcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			 <span class="n">colcount</span> <span class="o">&lt;</span> <span class="n">ncols</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
			 <span class="n">colcount</span><span class="o">++</span><span class="p">,</span> <span class="n">magptr</span><span class="o">++</span><span class="p">,</span> <span class="n">gxptr</span><span class="o">++</span><span class="p">,</span> <span class="n">gyptr</span><span class="o">++</span><span class="p">,</span> <span class="n">resultptr</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">short</span> <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">;</span>
			<span class="kt">short</span> <span class="n">m00</span><span class="p">,</span> <span class="n">gx</span><span class="p">,</span> <span class="n">gy</span><span class="p">;</span>
			<span class="kt">float</span> <span class="n">mag1</span><span class="p">,</span> <span class="n">mag2</span><span class="p">,</span> <span class="n">xperp</span><span class="p">,</span> <span class="n">yperp</span><span class="p">;</span>
			<span class="n">m00</span> <span class="o">=</span> <span class="o">*</span><span class="n">magptr</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m00</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="o">*</span><span class="n">resultptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">NOEDGE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">xperp</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">gx</span> <span class="o">=</span> <span class="o">*</span><span class="n">gxptr</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">m00</span><span class="p">);</span>
				<span class="n">yperp</span> <span class="o">=</span> <span class="p">(</span><span class="n">gy</span> <span class="o">=</span> <span class="o">*</span><span class="n">gyptr</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">m00</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">gx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">gy</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">gx</span> <span class="o">&gt;=</span> <span class="n">gy</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="cm">/* 111 */</span>
						<span class="cm">/* Left point */</span>
						<span class="n">z1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
						<span class="n">z2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">-</span> <span class="n">ncols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

						<span class="n">mag1</span> <span class="o">=</span> <span class="p">(</span><span class="n">m00</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">xperp</span> <span class="o">+</span> <span class="p">(</span><span class="n">z2</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">yperp</span><span class="p">;</span>

						<span class="cm">/* Right point */</span>
						<span class="n">z1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
						<span class="n">z2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">+</span> <span class="n">ncols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

						<span class="n">mag2</span> <span class="o">=</span> <span class="p">(</span><span class="n">m00</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">xperp</span> <span class="o">+</span> <span class="p">(</span><span class="n">z2</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">yperp</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">else</span>
					<span class="p">{</span>
						<span class="cm">/* 110 */</span>
						<span class="cm">/* Left point */</span>
						<span class="n">z1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">-</span> <span class="n">ncols</span><span class="p">);</span>
						<span class="n">z2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">-</span> <span class="n">ncols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

						<span class="n">mag1</span> <span class="o">=</span> <span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">z2</span><span class="p">)</span> <span class="o">*</span> <span class="n">xperp</span> <span class="o">+</span> <span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">m00</span><span class="p">)</span> <span class="o">*</span> <span class="n">yperp</span><span class="p">;</span>

						<span class="cm">/* Right point */</span>
						<span class="n">z1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">+</span> <span class="n">ncols</span><span class="p">);</span>
						<span class="n">z2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">+</span> <span class="n">ncols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

						<span class="n">mag2</span> <span class="o">=</span> <span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">z2</span><span class="p">)</span> <span class="o">*</span> <span class="n">xperp</span> <span class="o">+</span> <span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">m00</span><span class="p">)</span> <span class="o">*</span> <span class="n">yperp</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">else</span>
				<span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">gx</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">gy</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="cm">/* 101 */</span>
						<span class="cm">/* Left point */</span>
						<span class="n">z1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
						<span class="n">z2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">+</span> <span class="n">ncols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

						<span class="n">mag1</span> <span class="o">=</span> <span class="p">(</span><span class="n">m00</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">xperp</span> <span class="o">+</span> <span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">z2</span><span class="p">)</span> <span class="o">*</span> <span class="n">yperp</span><span class="p">;</span>

						<span class="cm">/* Right point */</span>
						<span class="n">z1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
						<span class="n">z2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">-</span> <span class="n">ncols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

						<span class="n">mag2</span> <span class="o">=</span> <span class="p">(</span><span class="n">m00</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">xperp</span> <span class="o">+</span> <span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">z2</span><span class="p">)</span> <span class="o">*</span> <span class="n">yperp</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">else</span>
					<span class="p">{</span>
						<span class="cm">/* 100 */</span>
						<span class="cm">/* Left point */</span>
						<span class="n">z1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">+</span> <span class="n">ncols</span><span class="p">);</span>
						<span class="n">z2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">+</span> <span class="n">ncols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

						<span class="n">mag1</span> <span class="o">=</span> <span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">z2</span><span class="p">)</span> <span class="o">*</span> <span class="n">xperp</span> <span class="o">+</span> <span class="p">(</span><span class="n">m00</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">yperp</span><span class="p">;</span>

						<span class="cm">/* Right point */</span>
						<span class="n">z1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">-</span> <span class="n">ncols</span><span class="p">);</span>
						<span class="n">z2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">-</span> <span class="n">ncols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

						<span class="n">mag2</span> <span class="o">=</span> <span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">z2</span><span class="p">)</span> <span class="o">*</span> <span class="n">xperp</span> <span class="o">+</span> <span class="p">(</span><span class="n">m00</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">yperp</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">gy</span> <span class="o">=</span> <span class="o">*</span><span class="n">gyptr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="n">gx</span> <span class="o">&gt;=</span> <span class="n">gy</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="cm">/* 011 */</span>
						<span class="cm">/* Left point */</span>
						<span class="n">z1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
						<span class="n">z2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">-</span> <span class="n">ncols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

						<span class="n">mag1</span> <span class="o">=</span> <span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">m00</span><span class="p">)</span> <span class="o">*</span> <span class="n">xperp</span> <span class="o">+</span> <span class="p">(</span><span class="n">z2</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">yperp</span><span class="p">;</span>

						<span class="cm">/* Right point */</span>
						<span class="n">z1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
						<span class="n">z2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">+</span> <span class="n">ncols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

						<span class="n">mag2</span> <span class="o">=</span> <span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">m00</span><span class="p">)</span> <span class="o">*</span> <span class="n">xperp</span> <span class="o">+</span> <span class="p">(</span><span class="n">z2</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">yperp</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">else</span>
					<span class="p">{</span>
						<span class="cm">/* 010 */</span>
						<span class="cm">/* Left point */</span>
						<span class="n">z1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">-</span> <span class="n">ncols</span><span class="p">);</span>
						<span class="n">z2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">-</span> <span class="n">ncols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

						<span class="n">mag1</span> <span class="o">=</span> <span class="p">(</span><span class="n">z2</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">xperp</span> <span class="o">+</span> <span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">m00</span><span class="p">)</span> <span class="o">*</span> <span class="n">yperp</span><span class="p">;</span>

						<span class="cm">/* Right point */</span>
						<span class="n">z1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">+</span> <span class="n">ncols</span><span class="p">);</span>
						<span class="n">z2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">+</span> <span class="n">ncols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

						<span class="n">mag2</span> <span class="o">=</span> <span class="p">(</span><span class="n">z2</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">xperp</span> <span class="o">+</span> <span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">m00</span><span class="p">)</span> <span class="o">*</span> <span class="n">yperp</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">else</span>
				<span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="n">gx</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">gy</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="cm">/* 001 */</span>
						<span class="cm">/* Left point */</span>
						<span class="n">z1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
						<span class="n">z2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">+</span> <span class="n">ncols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

						<span class="n">mag1</span> <span class="o">=</span> <span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">m00</span><span class="p">)</span> <span class="o">*</span> <span class="n">xperp</span> <span class="o">+</span> <span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">z2</span><span class="p">)</span> <span class="o">*</span> <span class="n">yperp</span><span class="p">;</span>

						<span class="cm">/* Right point */</span>
						<span class="n">z1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
						<span class="n">z2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">-</span> <span class="n">ncols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

						<span class="n">mag2</span> <span class="o">=</span> <span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">m00</span><span class="p">)</span> <span class="o">*</span> <span class="n">xperp</span> <span class="o">+</span> <span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">z2</span><span class="p">)</span> <span class="o">*</span> <span class="n">yperp</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">else</span>
					<span class="p">{</span>
						<span class="cm">/* 000 */</span>
						<span class="cm">/* Left point */</span>
						<span class="n">z1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">+</span> <span class="n">ncols</span><span class="p">);</span>
						<span class="n">z2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">+</span> <span class="n">ncols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

						<span class="n">mag1</span> <span class="o">=</span> <span class="p">(</span><span class="n">z2</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">xperp</span> <span class="o">+</span> <span class="p">(</span><span class="n">m00</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">yperp</span><span class="p">;</span>

						<span class="cm">/* Right point */</span>
						<span class="n">z1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">-</span> <span class="n">ncols</span><span class="p">);</span>
						<span class="n">z2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">magptr</span> <span class="o">-</span> <span class="n">ncols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

						<span class="n">mag2</span> <span class="o">=</span> <span class="p">(</span><span class="n">z2</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">xperp</span> <span class="o">+</span> <span class="p">(</span><span class="n">m00</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">yperp</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="cm">/* Now determine if the current point is a maximum point */</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">mag1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">mag2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="o">*</span><span class="n">resultptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">NOEDGE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mag2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
					<span class="o">*</span><span class="n">resultptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">NOEDGE</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="o">*</span><span class="n">resultptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">POSSIBLE_EDGE</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pgm_ioc">pgm_io.c</h3>

<p>读pgm格式图片的库，没有在原来的基础上变动。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*******************************************************************************
* FILE: pgm_io.c
* This code was written by Mike Heath. heath@csee.usf.edu (in 1995).
*******************************************************************************/</span>

<span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</span>
<span class="cm">/******************************************************************************
* Function: read_pgm_image
* Purpose: This function reads in an image in PGM format. The image can be
* read in from either a file or from standard input. The image is only read
* from standard input when infilename = NULL. Because the PGM format includes
* the number of columns and the number of rows in the image, these are read
* from the file. Memory to store the image is allocated in this function.
* All comments in the header are discarded in the process of reading the
* image. Upon failure, this function returns 0, upon sucess it returns 1.
******************************************************************************/</span>
<span class="kt">int</span> <span class="nf">read_pgm_image</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">infilename</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">image</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cols</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">71</span><span class="p">];</span>

	<span class="cm">/***************************************************************************
	* Open the input image file for reading if a filename was given. If no
	* filename was provided, set fp to read from standard input.
	***************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">infilename</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="n">stdin</span><span class="p">;</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">infilename</span><span class="p">,</span> <span class="s">"r"</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error reading the file %s in read_pgm_image().</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
					<span class="n">infilename</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/***************************************************************************
	* Verify that the image is in PGM format, read in the number of columns
	* and rows in the image and scan past all of the header information.
	***************************************************************************/</span>
	<span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"P5"</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"The file %s is not in PGM format in "</span><span class="p">,</span> <span class="n">infilename</span><span class="p">);</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"read_pgm_image().</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">!=</span> <span class="n">stdin</span><span class="p">)</span>
			<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'#'</span><span class="p">);</span> <span class="cm">/* skip all comment lines */</span>
	<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"%d %d"</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">);</span>
	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'#'</span><span class="p">);</span> <span class="cm">/* skip all comment lines */</span>

	<span class="cm">/***************************************************************************
	* Allocate memory to store the image then read the image from the file.
	***************************************************************************/</span>
	<span class="k">if</span> <span class="p">(((</span><span class="o">*</span><span class="n">image</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="o">*</span><span class="n">rows</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">cols</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Memory allocation failure in read_pgm_image().</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">!=</span> <span class="n">stdin</span><span class="p">)</span>
			<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">rows</span><span class="p">)</span> <span class="o">!=</span> <span class="n">fread</span><span class="p">((</span><span class="o">*</span><span class="n">image</span><span class="p">),</span> <span class="p">(</span><span class="o">*</span><span class="n">cols</span><span class="p">),</span> <span class="p">(</span><span class="o">*</span><span class="n">rows</span><span class="p">),</span> <span class="n">fp</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error reading the image data in read_pgm_image().</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">!=</span> <span class="n">stdin</span><span class="p">)</span>
			<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="n">free</span><span class="p">((</span><span class="o">*</span><span class="n">image</span><span class="p">));</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">!=</span> <span class="n">stdin</span><span class="p">)</span>
		<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************
* Function: write_pgm_image
* Purpose: This function writes an image in PGM format. The file is either
* written to the file specified by outfilename or to standard output if
* outfilename = NULL. A comment can be written to the header if coment != NULL.
******************************************************************************/</span>
<span class="kt">int</span> <span class="nf">write_pgm_image</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">outfilename</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">comment</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

	<span class="cm">/***************************************************************************
	* Open the output image file for writing if a filename was given. If no
	* filename was provided, set fp to write to standard output.
	***************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">outfilename</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="n">stdout</span><span class="p">;</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">outfilename</span><span class="p">,</span> <span class="s">"w"</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error writing the file %s in write_pgm_image().</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
					<span class="n">outfilename</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/***************************************************************************
	* Write the header information to the PGM file.
	***************************************************************************/</span>
	<span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">"P5</span><span class="se">\n</span><span class="s">%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">comment</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">70</span><span class="p">)</span>
			<span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">"# %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">comment</span><span class="p">);</span>
	<span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">maxval</span><span class="p">);</span>

	<span class="cm">/***************************************************************************
	* Write the image data to the file.
	***************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rows</span> <span class="o">!=</span> <span class="n">fwrite</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error writing the image data in write_pgm_image().</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">!=</span> <span class="n">stdout</span><span class="p">)</span>
			<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">!=</span> <span class="n">stdout</span><span class="p">)</span>
		<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************
* Function: read_ppm_image
* Purpose: This function reads in an image in PPM format. The image can be
* read in from either a file or from standard input. The image is only read
* from standard input when infilename = NULL. Because the PPM format includes
* the number of columns and the number of rows in the image, these are read
* from the file. Memory to store the image is allocated in this function.
* All comments in the header are discarded in the process of reading the
* image. Upon failure, this function returns 0, upon sucess it returns 1.
******************************************************************************/</span>
<span class="kt">int</span> <span class="nf">read_ppm_image</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">infilename</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">image_red</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">image_grn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">image_blu</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cols</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">71</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/***************************************************************************
	* Open the input image file for reading if a filename was given. If no
	* filename was provided, set fp to read from standard input.
	***************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">infilename</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="n">stdin</span><span class="p">;</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">infilename</span><span class="p">,</span> <span class="s">"r"</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error reading the file %s in read_ppm_image().</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
					<span class="n">infilename</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/***************************************************************************
	* Verify that the image is in PPM format, read in the number of columns
	* and rows in the image and scan past all of the header information.
	***************************************************************************/</span>
	<span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"P6"</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"The file %s is not in PPM format in "</span><span class="p">,</span> <span class="n">infilename</span><span class="p">);</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"read_ppm_image().</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">!=</span> <span class="n">stdin</span><span class="p">)</span>
			<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'#'</span><span class="p">);</span> <span class="cm">/* skip all comment lines */</span>
	<span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"%d %d"</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">);</span>
	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'#'</span><span class="p">);</span> <span class="cm">/* skip all comment lines */</span>

	<span class="cm">/***************************************************************************
	* Allocate memory to store the image then read the image from the file.
	***************************************************************************/</span>
	<span class="k">if</span> <span class="p">(((</span><span class="o">*</span><span class="n">image_red</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="o">*</span><span class="n">rows</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">cols</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Memory allocation failure in read_ppm_image().</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">!=</span> <span class="n">stdin</span><span class="p">)</span>
			<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(((</span><span class="o">*</span><span class="n">image_grn</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="o">*</span><span class="n">rows</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">cols</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Memory allocation failure in read_ppm_image().</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">!=</span> <span class="n">stdin</span><span class="p">)</span>
			<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(((</span><span class="o">*</span><span class="n">image_blu</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="o">*</span><span class="n">rows</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">cols</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Memory allocation failure in read_ppm_image().</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">!=</span> <span class="n">stdin</span><span class="p">)</span>
			<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">rows</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">cols</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="p">(</span><span class="o">*</span><span class="n">image_red</span><span class="p">)[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">fgetc</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="p">(</span><span class="o">*</span><span class="n">image_grn</span><span class="p">)[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">fgetc</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		<span class="p">(</span><span class="o">*</span><span class="n">image_blu</span><span class="p">)[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">fgetc</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">!=</span> <span class="n">stdin</span><span class="p">)</span>
		<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************
* Function: write_ppm_image
* Purpose: This function writes an image in PPM format. The file is either
* written to the file specified by outfilename or to standard output if
* outfilename = NULL. A comment can be written to the header if coment != NULL.
******************************************************************************/</span>
<span class="kt">int</span> <span class="nf">write_ppm_image</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">outfilename</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">image_red</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">image_grn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">image_blu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">comment</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">p</span><span class="p">;</span>

	<span class="cm">/***************************************************************************
	* Open the output image file for writing if a filename was given. If no
	* filename was provided, set fp to write to standard output.
	***************************************************************************/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">outfilename</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="n">stdout</span><span class="p">;</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">outfilename</span><span class="p">,</span> <span class="s">"w"</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error writing the file %s in write_pgm_image().</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
					<span class="n">outfilename</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/***************************************************************************
	* Write the header information to the PGM file.
	***************************************************************************/</span>
	<span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">"P6</span><span class="se">\n</span><span class="s">%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">comment</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">70</span><span class="p">)</span>
			<span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">"# %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">comment</span><span class="p">);</span>
	<span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">maxval</span><span class="p">);</span>

	<span class="cm">/***************************************************************************
	* Write the image data to the file.
	***************************************************************************/</span>
	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">rows</span> <span class="o">*</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">cols</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span> <span class="cm">/* Write the image in pixel interleaved format. */</span>
		<span class="n">fputc</span><span class="p">(</span><span class="n">image_red</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">fp</span><span class="p">);</span>
		<span class="n">fputc</span><span class="p">(</span><span class="n">image_grn</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">fp</span><span class="p">);</span>
		<span class="n">fputc</span><span class="p">(</span><span class="n">image_blu</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">!=</span> <span class="n">stdout</span><span class="p">)</span>
		<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
